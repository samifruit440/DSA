# 10.1 Définitions et Opérations

## Relation d'Équivalence

Une **relation d'équivalence** sur un ensemble E est une relation R telle que :

1. **Réflexive** : a R a pour tout a ∈ E
2. **Symétrique** : si a R b alors b R a
3. **Transitive** : si a R b et b R c alors a R c

**Propriété fondamentale :** Partitionne l'ensemble en classes d'équivalence disjointes.

```
Exemple : relation "même reste modulo 3" sur {0,1,2,3,4,5,6}

Classes d'équivalence :
- [0] = {0, 3, 6}
- [1] = {1, 4}
- [2] = {2, 5}

Chaque classe est disjointe, leur union = E
```

## Problématique des Ensembles Disjoints

Maintenir une **partition dynamique** d'un ensemble, avec opérations :

1. **Create(x)** : Créer un nouvel ensemble contenant uniquement x
2. **Find(x)** : Retourner le représentant de la classe de x
3. **Union(x, y)** : Fusionner les classes contenant x et y

```
Séquence d'opérations :

Create(1), Create(2), Create(3), Create(4)
Ensembles : {1}, {2}, {3}, {4}

Union(1, 2)
Ensembles : {1,2}, {3}, {4}

Union(3, 4)
Ensembles : {1,2}, {3,4}

Union(2, 3)
Ensembles : {1,2,3,4}

Find(1) = Find(4) ? OUI (même classe)
```

## Classe Abstracte

```java
public abstract class UnionFind {
    protected int[] parent;
    protected int numSets;
    
    public UnionFind(int n) {
        parent = new int[n];
        numSets = n;
        for (int i = 0; i < n; i++) {
            parent[i] = i;  // Chaque élément est son propre représentant
        }
    }
    
    /**
     * Retourner le représentant de l'ensemble contenant x
     */
    public abstract int find(int x);
    
    /**
     * Fusionner les ensembles contenant x et y
     */
    public abstract void union(int x, int y);
    
    /**
     * Vérifier si x et y sont dans le même ensemble
     */
    public boolean connected(int x, int y) {
        return find(x) == find(y);
    }
    
    /**
     * Nombre d'ensembles disjoints
     */
    public int getNumSets() {
        return numSets;
    }
}
```

## Implémentation Naïve

### Représentation par liste

Chaque ensemble est une liste. Recherche : O(n), Union : O(n)

```
Ensembles : {1,2}, {3}, {4,5}

Find(2) : parcourir {1,2} → trouvé, retourner représentant (ex. 1)
Union(2, 3) : 
  - Trouver représentant de 2 → 1
  - Trouver représentant de 3 → 3
  - Fusionner les listes {1,2} et {3}
```

### Représentation par arbre (pointeurs parent)

```java
public class UnionFindNaive extends UnionFind {
    
    public UnionFindNaive(int n) {
        super(n);
    }
    
    /**
     * Trouver la racine (représentant)
     */
    @Override
    public int find(int x) {
        while (parent[x] != x) {
            x = parent[x];
        }
        return x;
    }
    
    /**
     * Fusionner arbres (Union par le premier rencontré)
     */
    @Override
    public void union(int x, int y) {
        int rootX = find(x);  // Trouver la racine de x
        int rootY = find(y);  // Trouver la racine de y
        
        if (rootX != rootY) {  // Vérifier si déjà dans le même ensemble
            parent[rootX] = rootY;  // Lier rootX à rootY
            numSets--;  // Réduire le nombre d'ensembles
        }
    }
}
```

**Processus d'union de deux racines :**

Quand on appelle `union(x, y)` :

1. **Trouver les racines :**
   - `rootX = find(x)` : remonter depuis x jusqu'à sa racine
   - `rootY = find(y)` : remonter depuis y jusqu'à sa racine

2. **Vérifier si déjà fusionnés :**
   - Si `rootX == rootY` → déjà dans le même ensemble, rien à faire
   - Si `rootX != rootY` → ensembles distincts, fusionner

3. **Fusionner les deux arbres :**
   - `parent[rootX] = rootY` → faire pointer la racine X vers la racine Y
   - `numSets--` → diminuer le compteur d'ensembles

**Exemple visuel :**

```
Avant union(2, 5) :

Ensemble 1 :        Ensemble 2 :
    1                   4
   / \                 / \
  2   3               5   6

rootX = find(2) = 1
rootY = find(5) = 4

Opération : parent[1] = 4

Après union(2, 5) :

         4
       / | \
      1  5  6
     / \
    2   3

Tous les éléments {1,2,3,4,5,6} appartiennent au même ensemble
```

**Cas important : détection de cycle**

Dans un graphe, avant d'ajouter une arête (u, v) :
```java
if (find(u) == find(v)) {
    // Ajout de (u,v) créerait un cycle !
    return;
} else {
    union(u, v);  // Ajouter l'arête en sécurité
}
```

**Complexité :**
- Find : O(h) où h = hauteur arbre
- Union : O(h₁ + h₂)
- **Pire cas** : arbre dégénéré → Find O(n), Union O(n)

```
Pire cas : créer {1}, union(2,1), union(3,2), union(4,3)...
Arbre résultant : 1 ← 2 ← 3 ← 4 ← ... (chaîne)
Find(1) dans le dernier état = O(n)
```

## Arbre

```
Représentation naïve après plusieurs unions :

parent[1] = 2
parent[2] = 3
parent[3] = 4
parent[4] = 4  (racine)

Arbre :
    4 (racine)
    |
    3
    |
    2
    |
    1

Find(1) = 1 → 2 → 3 → 4 (4 étapes = O(n))
```

## Métriques de Performance

| Opération | Naïve | Union par hauteur | Compression chemin | Both |
|-----------|--------|------------------|--------------------|------|
| Create | O(1) | O(1) | O(1) | O(1) |
| Find | O(n) | O(log n) | O(log n) | O(α(n)) |
| Union | O(n) | O(log n) | O(log n) | O(α(n)) |

*Note : α(n) = inverse d'Ackermann ≈ 4.3 pour n = 2^65536*

---

**[↑ Retour à la section 10](README.md)** | **[← Retour à l'index](../INDEX.md)**

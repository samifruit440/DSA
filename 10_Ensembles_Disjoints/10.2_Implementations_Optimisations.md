# 10.2 Implémentations et Optimisations

## Optimisation 1 : Union par Hauteur

Toujours attacher l'arbre plus court à la racine du plus grand.

### Concept

```
Avant : arbre1 hauteur 5, arbre2 hauteur 2
Naïf : parent[racine1] = racine2 → hauteur 6
Optimisé : parent[racine2] = racine1 → hauteur 5
```

### Implémentation

```java
public class UnionFindByHeight extends UnionFind {
    private int[] height;
    
    public UnionFindByHeight(int n) {
        super(n);
        height = new int[n];
        for (int i = 0; i < n; i++) {
            height[i] = 0;  // Hauteur initiale
        }
    }
    
    @Override
    public int find(int x) {
        while (parent[x] != x) {
            x = parent[x];
        }
        return x;
    }
    
    @Override
    public void union(int x, int y) {
        int rootX = find(x);
        int rootY = find(y);
        
        if (rootX == rootY) return;
        
        // Attacher arbre plus court à plus grand
        if (height[rootX] < height[rootY]) {
            parent[rootX] = rootY;
        } else if (height[rootX] > height[rootY]) {
            parent[rootY] = rootX;
        } else {
            // Même hauteur : choisir un, augmenter sa hauteur
            parent[rootY] = rootX;
            height[rootX]++;
        }
        
        numSets--;
    }
}
```

**Propriété :** Arbre avec n nœuds a hauteur ≤ log₂(n)

**Complexité :** Find O(log n), Union O(log n)

## Optimisation 2 : Compression de Chemin

Pendant Find, rediriger tous les nœuds visités directement à la racine.

### Concept

```
Avant :
    4 (racine)
    |
    3
    |
    2
    |
    1

Find(1) : 1 → 2 → 3 → 4

Après compression :
    4
   /|\
  3 2 1  (tous pointent directement à racine)

Prochains Find(1) = O(1)
```

### Implémentation

```java
public class UnionFindPathCompression extends UnionFind {
    
    @Override
    public int find(int x) {
        if (parent[x] != x) {
            parent[x] = find(parent[x]);  // Compression
        }
        return parent[x];
    }
    
    @Override
    public void union(int x, int y) {
        int rootX = find(x);
        int rootY = find(y);
        
        if (rootX != rootY) {
            parent[rootX] = rootY;
            numSets--;
        }
    }
}
```

**Amortissement :** Beaucoup de Find bénéficient de la compression → très rapide

## Optimisation Combinée

Appliquer **Union par Hauteur + Compression de Chemin** simultanément.

```java
public class UnionFindOptimized extends UnionFind {
    private int[] height;
    
    public UnionFindOptimized(int n) {
        super(n);
        height = new int[n];
    }
    
    @Override
    public int find(int x) {
        if (parent[x] != x) {
            parent[x] = find(parent[x]);  // Compression
        }
        return parent[x];
    }
    
    @Override
    public void union(int x, int y) {
        int rootX = find(x);  // Déjà compressé
        int rootY = find(y);  // Déjà compressé
        
        if (rootX == rootY) return;
        
        // Union par hauteur
        if (height[rootX] < height[rootY]) {
            parent[rootX] = rootY;
        } else if (height[rootX] > height[rootY]) {
            parent[rootY] = rootX;
        } else {
            parent[rootY] = rootX;
            height[rootX]++;
        }
        
        numSets--;
    }
}
```

**Complexité Amortie :** O(α(n)) pour tous les cas

où α(n) = inverse d'Ackermann ≈ 4 pour n < 2^65536

## Analyse de Complexité

### Cas Naïf

```
m opérations (Find/Union) sur n éléments
Pire cas (arbre dégénéré) : O(m × n)

Exemple :
Create(1)...Create(n)
union(2,1), union(3,2), ..., union(n, n-1)
→ Arbre linéaire, Find(1) = O(n)
m × Find = O(m × n)
```

### Union par Hauteur

```
Théorème : Arbre avec n nœuds et hauteur h a la propriété h ≤ log₂(n)

Preuve par induction :
- Hauteur augmente seulement quand on fusionne 2 arbres de même hauteur h
- Fusion de 2 arbres de n₁ et n₂ nœuds → arbre de hauteur h+1
- Donc : 2^h ≤ n₁ et 2^h ≤ n₂  →  2^(h+1) ≤ n₁ + n₂
- Par conséquent : h ≤ log₂(n)

m opérations : O(m log n)
```

### Avec Compression de Chemin

```
Pour chaque Find qui ne mène pas à la racine :
- Rediriger le nœud à la racine
- Prochains Find pour ce nœud = O(1)

m Find + n Union : O(m + n × log n)

Avec Union par hauteur également :
O(m × α(n) + n × α(n)) = O((m + n) × α(n))
```

## Tableau Comparatif

| Opération | Naïf | Hauteur | Compression | Both |
|-----------|------|---------|-------------|------|
| Find(x) seul | O(n) | O(log n) | O(log n) | O(α(n)) |
| m Find + Union | O(mn) | O((m+n)log n) | O(m log n) | O((m+n)α(n)) |
| Espace | O(n) | O(n) | O(n) | O(n) |

**Exemple pratique :**
```
n = 10⁶ éléments, m = 10⁶ opérations

Naïf : 10¹² opérations (plusieurs secondes)
Hauteur : ~2×10⁷ opérations (acceptable)
Compression : ~2×10⁶ opérations (très rapide)
Both : ~4×10⁶ opérations (ultra rapide)
```

---

**[↑ Retour à la section 10](README.md)** | **[← Retour à l'index](../INDEX.md)**

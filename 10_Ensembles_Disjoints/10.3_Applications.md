# 10.3 Applications

## Application 1 : Détection de Cycles avec Kruskal

Utiliser Union-Find pour **déterminer rapidement** si ajouter une arête créerait un cycle.

### Concept

```
Propriété : 2 sommets u et v sont dans le même ensemble
           ⟺ il existe un chemin entre eux dans l'arbre construis

Ajouter arête (u,v) crée cycle ⟺ Find(u) == Find(v)
```

### Algorithme

```java
public List<Edge> kruskalWithUnionFind(List<Edge> edges, int numVertices) {
    List<Edge> mst = new ArrayList<>();
    
    // Trier arêtes par poids
    Collections.sort(edges, (e1, e2) -> Integer.compare(e1.weight, e2.weight));
    
    UnionFind uf = new UnionFind(numVertices);
    
    for (Edge e : edges) {
        // Si les sommets ne sont pas dans le même ensemble
        if (uf.find(e.u) != uf.find(e.v)) {
            // Ajouter l'arête (elle ne crée pas de cycle)
            mst.add(e);
            uf.union(e.u, e.v);
            
            // MST complet
            if (mst.size() == numVertices - 1) {
                break;
            }
        }
        // Sinon : ignorer cette arête (créerait un cycle)
    }
    
    return mst;
}
```

### Exemple

```
Graphe :
    1 ---(5)--- 2
    |           |
   (1)         (3)
    |           |
    3 ---(2)--- 4

Arêtes triées par poids croissant :
1. (1,3) : poids 1
2. (3,4) : poids 2
3. (4,2) : poids 3
4. (1,2) : poids 5

Itération 1 : Traiter (1,3) poids 1
  Find(1)=1, Find(3)=3 → Différents (pas connectés)
  Ajouter (1,3) à MST
  Union(1,3) : parent[3] = 1
  Ensembles : {1,3}, {2}, {4}

Itération 2 : Traiter (3,4) poids 2
  Find(3)=1, Find(4)=4 → Différents
  Ajouter (3,4) à MST
  Union(1,4) : parent[4] = 1
  Ensembles : {1,3,4}, {2}

Itération 3 : Traiter (4,2) poids 3
  Find(4)=1, Find(2)=2 → Différents
  Ajouter (4,2) à MST
  Union(1,2) : parent[2] = 1
  Ensembles : {1,2,3,4}

Itération 4 : Traiter (1,2) poids 5
  Find(1)=1, Find(2)=1 → IDENTIQUES (déjà connectés)
  Ignorer cette arête (créerait un cycle 1-2-4-3-1)

Résultat MST : {(1,3), (3,4), (4,2)} avec coût 6
```

**Complexité :** O(|E| log |E|) pour tri + O(|E| α(|V|)) pour Union-Find

## Application 2 : Composantes Connexes

Trouver toutes les **composantes connexes** d'un graphe non orienté.

### Algorithme

```java
public List<List<Integer>> connectedComponents(int numVertices, List<Edge> edges) {
    UnionFind uf = new UnionFind(numVertices);
    
    // Construire ensembles
    for (Edge e : edges) {
        uf.union(e.u, e.v);
    }
    
    // Grouper par racine
    Map<Integer, List<Integer>> components = new HashMap<>();
    for (int i = 0; i < numVertices; i++) {
        int root = uf.find(i);
        components.computeIfAbsent(root, k -> new ArrayList<>()).add(i);
    }
    
    return new ArrayList<>(components.values());
}
```

### Exemple

```
Graphe :
    1 --- 2       5
    |     |       |
    3     4       6

Arêtes : (1,2), (2,4), (1,3), (5,6)

Après unions :
  Find(1) = Find(2) = Find(3) = Find(4) = 1
  Find(5) = Find(6) = 5

Composantes : {1,2,3,4}, {5,6}
```

**Complexité :** O(|E| α(|V|) + |V|)

## Application 3 : Génération de Labyrinthes

Créer un labyrinthe parfait (exactement un chemin entre deux points).

### Algorithme d'Aldous-Broder

1. Commencer avec grille où toutes les cellules sont murs
2. Choisir cellule arbitraire, la marquer comme visitée
3. Choisir voisin non visité, créer passage, marquer visité
4. Répéter tant qu'il y a des cellules non visitées

### Variante avec Union-Find

```java
public void generateMaze(int rows, int cols) {
    UnionFind uf = new UnionFind(rows * cols);
    
    // Toutes les arêtes internes
    List<Edge> edges = new ArrayList<>();
    
    // Arêtes horizontales
    for (int r = 0; r < rows; r++) {
        for (int c = 0; c < cols - 1; c++) {
            int u = r * cols + c;
            int v = r * cols + (c + 1);
            edges.add(new Edge(u, v, 1));
        }
    }
    
    // Arêtes verticales
    for (int r = 0; r < rows - 1; r++) {
        for (int c = 0; c < cols; c++) {
            int u = r * cols + c;
            int v = (r + 1) * cols + c;
            edges.add(new Edge(u, v, 1));
        }
    }
    
    // Mélanger les arêtes
    Collections.shuffle(edges);
    
    boolean[][] maze = new boolean[rows][cols * 2 - 1];
    // true = passage ouvert, false = mur
    
    // Ajouter arêtes tant que cela ne crée pas de cycle
    for (Edge e : edges) {
        if (uf.find(e.u) != uf.find(e.v)) {
            uf.union(e.u, e.v);
            
            // Ouvrir le passage
            int u = e.u;
            int v = e.v;
            
            if (u / cols == v / cols) {  // Horizontale
                int r = u / cols;
                int c = Math.min(u % cols, v % cols);
                maze[r][2 * c + 1] = true;
            } else {  // Verticale
                int c = u % cols;
                int r = Math.min(u / cols, v / cols);
                maze[2 * r + 1][c] = true;
            }
        }
    }
}
```

### Exemple petit labyrinthe (3×3)

```
Grille initiale (tous murs) :
+--+--+--+
|  |  |  |
+--+--+--+
|  |  |  |
+--+--+--+
|  |  |  |
+--+--+--+

Après génération (arêtes aléatoires acceptées) :
+--+--+--+
|     |  |
+  +--+  +
|  |     |
+--+  +--+
|  |  |  |
+--+--+--+

(Exactement 8 arêtes pour 9 sommets = arbre)
```

**Propriété :** Labyrinthe parfait = spanning tree du graphe grille

## Application 4 : Équivalence de Variables

Problème : Ensemble de requêtes `equivalence(x, y)` et `unify(x, y)`

```java
public class EquivalenceChecker {
    private UnionFind uf;
    
    public EquivalenceChecker(int n) {
        uf = new UnionFind(n);
    }
    
    /**
     * Unifier variables x et y
     */
    public void unify(int x, int y) {
        uf.union(x, y);
    }
    
    /**
     * Vérifier si x et y sont équivalentes
     */
    public boolean equivalent(int x, int y) {
        return uf.find(x) == uf.find(y);
    }
    
    /**
     * Nombre de classes d'équivalence
     */
    public int numClasses() {
        return uf.getNumSets();
    }
}
```

**Exemple :**
```
Requêtes :
  unify(1, 2)  → Classes : {1,2}, {3}, {4}
  unify(2, 3)  → Classes : {1,2,3}, {4}
  unify(1, 4)  → Classes : {1,2,3,4}
  
  equivalent(1, 3) → true
  equivalent(2, 4) → true
  equivalent(3, 4) → true
```

## Recommandations d'Application

| Problème | Solution | Complexité |
|----------|----------|-----------|
| Cycles dans graphe | Union-Find | O(\|E\| α(\|V\|)) |
| Composantes connexes | Union-Find | O(\|E\| + \|V\|) |
| MST Kruskal | Union-Find | O(\|E\| log \|E\|) |
| Labyrinthes | Union-Find | O(n² log n) |
| Équivalence | Union-Find | O(m α(n)) |

**Clé du succès :** Reconnaître que le problème implique des **ensembles disjoints à fusionner dynamiquement**.

---

**[↑ Retour à la section 10](README.md)** | **[← Retour à l'index](../INDEX.md)**

# 3.2 Résolution des Collisions

Quand deux clés différentes produisent le même hash, une **collision** se produit. Il faut une stratégie pour les gérer.

## Chaînage (Separate Chaining)

### Concept

Chaque position de la table contient une **liste chaînée** de tous les enregistrements qui hashent à cette position.

```
Index :    [0] [1] [2] [3] [4]
           |   |   |   |   |
Valeurs:   5 → 7 → 1    11  4
```

### Implémentation

```java
public class HashTableWithChaining<K, V> {
    private class Entry<K, V> {
        K key;
        V value;
        Entry(K key, V value) {
            this.key = key;
            this.value = value;
        }
    }
    
    private LinkedList<Entry<K, V>>[] table;
    private int size;
    
    @SuppressWarnings("unchecked")
    public HashTableWithChaining(int capacity) {
        table = new LinkedList[capacity];
        for (int i = 0; i < capacity; i++) {
            table[i] = new LinkedList<>();
        }
        size = 0;
    }
    
    private int hash(K key) {
        return Math.abs(key.hashCode()) % table.length;
    }
    
    public void put(K key, V value) {
        int index = hash(key);
        LinkedList<Entry<K, V>> bucket = table[index];
        
        // Vérifier si la clé existe déjà
        for (Entry<K, V> entry : bucket) {
            if (entry.key.equals(key)) {
                entry.value = value;
                return;
            }
        }
        
        // Ajouter une nouvelle entrée
        bucket.add(new Entry<>(key, value));
        size++;
    }
    
    public V get(K key) {
        int index = hash(key);
        LinkedList<Entry<K, V>> bucket = table[index];
        
        for (Entry<K, V> entry : bucket) {
            if (entry.key.equals(key)) {
                return entry.value;
            }
        }
        return null;
    }
}
```

### Complexité

| Opération | Meilleur cas | Cas moyen | Pire cas |
|-----------|-------------|----------|----------|
| `get(key)` | O(1) | O(1 + fc) | O(n) |
| `put(key, value)` | O(1) | O(1 + fc) | O(n) |
| `remove(key)` | O(1) | O(1 + fc) | O(n) |

Où **fc** = facteur de charge (nombre d'éléments / taille table)

### Avantages et inconvénients

**Avantages :**
- Simple à comprendre et implémenter
- Pas de clustering
- Suppression facile

**Inconvénients :**
- Mémoire supplémentaire pour les pointeurs
- Cache non-optimal (sauts mémoire)
- Performance dégradée si collisions nombreuses

## Sondage (Open Addressing)

Dans le **sondage**, les éléments sont stockés **directement dans la table**. Quand une collision se produit, on cherche une autre position libre.

### Sondage linéaire : f(i) = i

Essayer les positions suivantes de manière linéaire.

```
Hashé à : [5] → [6] → [7]  (si [5] occupé, essayer [6], puis [7], etc.)

Insertion de 27 (hash = 5) :
Étape 1 : table[5] occupé
Étape 2 : table[6] occupé
Étape 3 : table[7] libre → insérer 27

Table après : [... 27 ...]
```

```java
public void put(K key, V value) {
    int index = hash(key);
    int i = 0;
    
    while (table[(index + i) % table.length] != null) {
        i++;
        if (i == table.length) throw new RuntimeException("Table pleine");
    }
    
    table[(index + i) % table.length] = new Entry<>(key, value);
}
```

**Problème** : Crée des **amas** (clustering) où les collisions s'accumulent.

```
Mauvais :  [x] [x] [x] [x] [ ] [ ]  ← Grand amas
```

### Sondage quadratique : f(i) = i²

La distance augmente au carré pour réduire le clustering.

```
Hashé à : [5] → [5+1²] → [5+2²] → [5+3²] → ...

Positions essayées : 5, 6 (5+1), 9 (5+4), 14 (5+9), 21 (5+16), ...
```

**Important** : Le sondage quadratique garantit de trouver une case libre SI :
- La table a une taille **première**
- Le facteur de charge fc ≤ 0.5

```java
public void put(K key, V value) {
    int index = hash(key);
    int i = 0;
    
    while (table[(index + i*i) % table.length] != null) {
        i++;
        if (i == table.length) throw new RuntimeException("Table pleine");
    }
    
    table[(index + i*i) % table.length] = new Entry<>(key, value);
}
```

**Avantage** : Réduit le clustering primaire.

**Inconvénient** : Peut créer du **clustering secondaire** si plusieurs clés hashent à proximité.

### Dispersement double (Double Hashing) : f(i) = i × H₂(key)

Utilise une **deuxième fonction de hash** pour déterminer l'incrément.

```
f(i) = i × H₂(key)
Positions essayées : H₁(key), H₁(key)+H₂(key), H₁(key)+2×H₂(key), ...

Exemple :
H₁("alice") = 5
H₂("alice") = 3
Positions : 5, 8 (5+3), 11 (5+6), 14 (5+9), ...
```

**Condition importante** : H₂(key) doit être **premier avec** la taille de la table (ou la taille doit être première) pour garantir que toutes les positions soient visitées.

**Choix classique pour H₂** : `H₂(key) = R - (key % R)` où R est un nombre premier < taille_table

```java
private int hash2(K key) {
    // R = nombre premier légèrement inférieur à la taille
    int R = 7;  // Exemple si taille = 11
    return R - (Math.abs(key.hashCode()) % R);
}

public void put(K key, V value) {
    int index = hash(key);
    int step = hash2(key);
    int i = 0;
    
    while (table[(index + i * step) % table.length] != null) {
        i++;
        if (i == table.length) throw new RuntimeException("Table pleine");
    }
    
    table[(index + i * step) % table.length] = new Entry<>(key, value);
}
```

**Avantage** : Meilleure distribution, évite clustering primaire ET secondaire.

**Inconvénient** : Plus complexe à implémenter, nécessite 2 calculs de hash.

## Comparaison des stratégies

| Stratégie | Clustering | Suppression | Mémoire | Complexité |
|-----------|-----------|-----------|---------|-----------|
| Chaînage | ✗ Non | ✓ Facile | - Extra (listes) | O(1 + fc) |
| Sondage linéaire | ✓ Primaire | Difficile | ✓ Moins | O((1/(1-fc))²) |
| Sondage quadratique | Modéré | Difficile | ✓ Moins | O(1 + 1/(1-fc)) |
| Double hashing | ✗ Non | Difficile | ✓ Moins | O(1/(1-fc)) |

**Recommandations :**
- Faible charge (fc < 0.5) : **Chaînage** ou **sondage simple**
- Haute performance : **Double hashing** ou **sondage quadratique**

---

**[↑ Retour à la section 3](README.md)** | **[← Retour à l'index](../INDEX.md)**

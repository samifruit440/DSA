# 3.1 Fonctions de Dispersement

## Problématique de la recherche rapide

Pour accéder rapidement à des données, nous avons besoin d'une structure qui permet une recherche en temps O(1) en moyenne. Les arbres de recherche garantissent O(log n), mais le hachage peut faire mieux.

**Défi** : Comment accéder directement à un élément sans vérifier tous les autres ?

**Solution** : Utiliser une fonction de dispersement (hash) pour convertir une clé en un index direct dans un tableau.

## Définitions

### Clé
La clé est l'identifiant unique d'un élément que nous souhaitons stocker et récupérer.

```java
String key = "alice";
int value = 25;
```

### Fonction de dispersement H(clé)

La fonction hash transforme une clé en un index du tableau.

```java
int index = hashFunction(key);
```

Propriété : Déterministe - La même clé doit toujours produire le même hash.

### Collision

Une **collision** se produit quand deux clés différentes produisent le même hash.

```java
H("alice") = 5
H("bob") = 5  // Collision !
```

### Enregistrement synonyme

Les enregistrements avec le même hash sont appelés **synonymes**.

## Facteur de compression (fc) / facteur de charge (λ)

Le **facteur de compression** (ou facteur de charge λ) est le rapport entre le nombre de clés et la taille de la table.

$$\lambda = fc = \frac{\text{nombre d'éléments}}{\text{taille de la table}}$$

```java
int elementsStored = 7;
int tableSize = 10;
double loadFactor = (double) elementsStored / tableSize; // λ = 0.7
```

**Impact** :
- fc petit (< 0.5) → Peu de collisions, plus de mémoire gaspillée
- fc élevé (> 0.9) → Beaucoup de collisions, moins de mémoire

**Seuils recommandés** :
- **Chaînage** : fc ≤ 1.0 (peut dépasser 1)
- **Sondage linéaire** : fc ≤ 0.5
- **Sondage quadratique** : fc ≤ 0.5 (table de taille **première**)
- **Double hashing** : fc ≤ 0.7-0.8

## Qualités d'une bonne fonction de dispersement

### 1. Uniformité

Une bonne fonction hash doit distribuer les clés **uniformément** sur tout l'espace des indices. Chaque position du tableau doit avoir la même probabilité d'être choisie.

```
Mauvais :    [1] [2] [3] [4] [5]  Collisions
             [x] [x] [x] [ ] [ ]

Bon :        [1] [2] [3] [4] [5]  Distribution uniforme
             [ ] [x] [ ] [x] [x]
```

### 2. Rapidité

La fonction hash doit être **calculée rapidement** en O(1), sinon elle ne sert à rien.

```java
// Rapide ✓
int hash = key % tableSize;

// Lent ✗
int hash = expensiveCalculation(key);
```

## Exemples de fonctions de dispersement

### Modulo N

La fonction la plus simple et la plus courante.

```java
public int hash(int key, int tableSize) {
    return Math.abs(key) % tableSize;
}

// Exemple
hash(27, 10) = 27 % 10 = 7
hash(47, 10) = 47 % 10 = 7  // Collision avec 27
hash(15, 10) = 15 % 10 = 5
```

**Important** : 
- tableSize devrait être un nombre **premier** pour améliorer l'uniformité et réduire les collisions
- Utiliser `Math.abs()` pour gérer les nombres négatifs
- Éviter les puissances de 2 (2, 4, 8, 16, etc.) car elles ne distribuent que selon les derniers bits

```java
// Mauvais : tableSize = 10 = 2 × 5 (pas premier)
// Mauvais : tableSize = 16 = 2⁴ (puissance de 2)
// Bon : tableSize = 11, 13, 17, 19, 23... (nombres premiers)
```

### Chaînes alphabétiques

Pour les chaînes de caractères, convertir les caractères en nombres.

#### Approche naïve

```java
public int hashString(String key, int tableSize) {
    int hash = 0;
    for (char c : key.toCharArray()) {
        hash += (int) c;  // Ajouter le code ASCII
    }
    return hash % tableSize;
}

// Problème : "ab" et "ba" donnent le même hash !
```

#### Approche pondérée (Horner's method)

```java
public int hashString(String key, int tableSize) {
    int hash = 0;
    int base = 31;  // Nombre premier
    
    for (char c : key.toCharArray()) {
        hash = (hash * base + (int) c) % tableSize;
    }
    return hash < 0 ? hash + tableSize : hash;
}

// "ab" : (0 * 31 + 97) * 31 + 98 = 3105
// "ba" : (0 * 31 + 98) * 31 + 97 = 3135  (différent !)
```

### Fonction de multiplication

Utilise un nombre spécial (nombre d'or) pour une meilleure distribution.

```java
public int hashMultiplication(int key, int tableSize) {
    double A = 0.6180339887; // (√5 - 1) / 2
    return (int) (tableSize * (key * A % 1));
}
```

## Bonne pratique

```java
public class HashTable<K, V> {
    private static final int INITIAL_SIZE = 11; // Nombre premier
    private Entry<K, V>[] table;
    
    public HashTable() {
        table = new Entry[INITIAL_SIZE];
    }
    
    private int hash(K key) {
        // Utiliser hashCode() de Java
        int hashCode = key.hashCode();
        // Réduire à la taille de la table
        return Math.abs(hashCode) % table.length;
    }
    
    public void put(K key, V value) {
        int index = hash(key);
        // Stocker à l'index ou gérer les collisions
    }
}
```

---

**[↑ Retour à la section 3](README.md)** | **[← Retour à l'index](../INDEX.md)**

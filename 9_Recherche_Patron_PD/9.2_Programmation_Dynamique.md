# 9.2 Programmation Dynamique (Dynamic Programming)

## Concept Fondamental

**Programmation Dynamique** : Technique de résolution où un problème complexe est décomposé en **sous-problèmes chevauchants** et leurs solutions sont **memoïsées** pour éviter recalculs.

### Conditions d'application

1. **Sous-structure optimale** : solution = solutions des sous-problèmes
2. **Sous-problèmes chevauchants** : mêmes sous-problèmes résolus plusieurs fois
3. **Memoïsation** : stocker résultats des sous-problèmes

```
Exemple Fibonacci récursif naïf :
f(5) = f(4) + f(3)
f(4) = f(3) + f(2)
f(3) = f(2) + f(1)  ← f(3) calculé 2 fois!

Avec PD : calculer f(1), f(2), f(3), f(4), f(5) une fois chacun
```

## Approches

### 1. Top-Down (Memoïsation)

Récursion avec stockage des résultats.

```java
private Map<Integer, Long> memo = new HashMap<>();

public long fibMemo(int n) {
    if (n <= 1) return n;
    if (memo.containsKey(n)) {
        return memo.get(n);
    }
    
    long result = fibMemo(n - 1) + fibMemo(n - 2);
    memo.put(n, result);
    return result;
}

// fib(40) en ms au lieu de millénaires en naïf!
```

**Avantage :** Intuitif, ne calcule que ce qui est nécessaire

### 2. Bottom-Up (Tabulaire)

Remplir table des solutions en partant des cas de base.

```java
public long fibTable(int n) {
    if (n <= 1) return n;
    
    long[] dp = new long[n + 1];
    dp[0] = 0;
    dp[1] = 1;
    
    for (int i = 2; i <= n; i++) {
        dp[i] = dp[i - 1] + dp[i - 2];
    }
    
    return dp[n];
}

// Complexité : O(n), Espace : O(n) (peut être O(1) pour Fibonacci)
```

**Avantage :** Efficace, pas d'appels récursifs

## Plus Long Sous-Séquence Commune (PLSC)

Trouver la **plus longue sous-séquence** commune à deux chaînes.

```
Chaîne 1 : "AGGTAB"
Chaîne 2 : "GXTXAYB"

PLSC : "GTAB" (longueur 4)
       A G G T A B
       G X T X A Y B
       - - - - - - -
       ✓ ✓ ✓ ✓     (positions)
```

### Approche PD

```java
public int lcs(String str1, String str2) {
    int m = str1.length();
    int n = str2.length();
    
    // dp[i][j] = longueur PLSC de str1[0..i-1] et str2[0..j-1]
    int[][] dp = new int[m + 1][n + 1];
    
    // Remplir la table
    for (int i = 1; i <= m; i++) {
        for (int j = 1; j <= n; j++) {
            if (str1.charAt(i - 1) == str2.charAt(j - 1)) {
                // Caractères correspondent
                dp[i][j] = 1 + dp[i - 1][j - 1];
            } else {
                // Prendre le meilleur des deux options
                dp[i][j] = Math.max(dp[i - 1][j], dp[i][j - 1]);
            }
        }
    }
    
    return dp[m][n];
}
```

**Table pour exemple :**
```
        ""  G  X  T  X  A  Y  B
    ""   0  0  0  0  0  0  0  0
    A    0  0  0  0  0  1  1  1
    G    0  1  1  1  1  1  1  1
    G    0  1  1  1  1  1  1  1
    T    0  1  1  2  2  2  2  2
    A    0  1  1  2  2  3  3  3
    B    0  1  1  2  2  3  3  4
```

**Complexité :** O(m × n), Espace : O(m × n)

### Reconstruction de la solution

```java
public String reconstructLCS(String str1, String str2) {
    int m = str1.length();
    int n = str2.length();
    int[][] dp = new int[m + 1][n + 1];
    
    // Remplir dp (même code que avant)
    // ...
    
    // Remonter la table
    StringBuilder result = new StringBuilder();
    int i = m, j = n;
    
    while (i > 0 && j > 0) {
        if (str1.charAt(i - 1) == str2.charAt(j - 1)) {
            result.insert(0, str1.charAt(i - 1));
            i--;
            j--;
        } else if (dp[i - 1][j] > dp[i][j - 1]) {
            i--;
        } else {
            j--;
        }
    }
    
    return result.toString();
}
```

## Autres Exemples Classiques

### Pièces de Monnaie (Coin Change)

Nombre minimum de pièces pour faire une somme.

```java
public int coinChange(int[] coins, int amount) {
    int[] dp = new int[amount + 1];
    dp[0] = 0;
    
    for (int i = 1; i <= amount; i++) {
        dp[i] = Integer.MAX_VALUE;
        for (int coin : coins) {
            if (coin <= i && dp[i - coin] != Integer.MAX_VALUE) {
                dp[i] = Math.min(dp[i], 1 + dp[i - coin]);
            }
        }
    }
    
    return dp[amount];
}
```

**Complexité :** O(amount × coins.length)

### Problème du Sac à Dos (Knapsack)

Maximiser valeur sans dépasser capacité.

```java
public int knapsack(int[] weights, int[] values, int capacity) {
    int n = weights.length;
    int[][] dp = new int[n + 1][capacity + 1];
    
    for (int i = 1; i <= n; i++) {
        for (int w = 1; w <= capacity; w++) {
            if (weights[i - 1] <= w) {
                // Prendre ou ne pas prendre
                dp[i][w] = Math.max(
                    dp[i - 1][w],  // Ne pas prendre
                    values[i - 1] + dp[i - 1][w - weights[i - 1]]  // Prendre
                );
            } else {
                dp[i][w] = dp[i - 1][w];
            }
        }
    }
    
    return dp[n][capacity];
}
```

**Complexité :** O(n × capacity)

## Coefficients Binomiaux

**Problème :** Calculer $\binom{n}{k} = \frac{n!}{k!(n-k)!}$ efficacement.

**Formule récursive :**
$$\binom{n}{k} = \binom{n-1}{k} + \binom{n-1}{k-1}$$

avec conditions de base : $\binom{n}{0} = \binom{n}{n} = 1$

### Version récursive naïve (recouvrement de sous-problèmes)

```java
public int combinatoire(int n, int k) {
    if (n < 0 || k < 0) return -1;
    if (n == k || k == 0) return 1;
    
    return combinatoire(n - 1, k) + combinatoire(n - 1, k - 1);
}
```

**Problème :** Pour calculer $\binom{4}{2}$ :
```
                    C(4,2)
                   /      \
              C(3,2)      C(3,1)
             /     \      /     \
        C(2,2)  C(2,1)  C(2,1)  C(2,0)
               /    \   /    \
           C(1,1) C(1,0) C(1,1) C(1,0)
```

On calcule **plusieurs fois** les mêmes sous-problèmes (ex: $\binom{2}{1}$ calculé 2 fois, $\binom{1}{1}$ et $\binom{1}{0}$ calculés 2 fois chacun).

### Version PD (optimal)

```java
public int combinatoireDynamique(int n, int k) {
    if (n < 0 || k < 0) return -1;
    
    int[][] M = new int[n + 1][k + 1];
    
    for (int i = 0; i <= n; i++) {
        for (int j = 0; j <= Math.min(i, k); j++) {
            if (i == j || j == 0) {
                M[i][j] = 1;
            } else {
                M[i][j] = M[i - 1][j] + M[i - 1][j - 1];
            }
        }
    }
    
    return M[n][k];
}
```

**Tableau pour $\binom{4}{2}$ :**
```
i\j    0    1    2
 0     1
 1     1    1
 2     1    2    1
 3     1    3    3
 4     1    4    6

Résultat : M[4][2] = 6
```

**Complexité :** O(n × k)

### Optimisation mémoire

On peut réduire l'espace de O(n × k) à O(k) car chaque ligne ne dépend que de la précédente :

```java
public int combinatoireOptimise(int n, int k) {
    int[] M = new int[k + 1];
    M[0] = 1;
    
    for (int i = 1; i <= n; i++) {
        for (int j = Math.min(i, k); j > 0; j--) {
            M[j] = M[j] + M[j - 1];
        }
    }
    
    return M[k];
}
```

**Complexité :** O(n × k), Espace : O(k)

## Autre Exemple : Multiplication de Chaînes de Matrices

**Problème :** Trouver la manière optimale de parenthéser la multiplication de matrices $A_1 \times A_2 \times ... \times A_n$ pour minimiser le nombre d'opérations scalaires.

- Matrice $A$ ($p \times q$) $\times$ Matrice $B$ ($q \times r$) coûte $p \cdot q \cdot r$ opérations.
- $(A \times B) \times C$ vs $A \times (B \times C)$ peut avoir des coûts très différents.

**Approche PD :**
- $m[i,j]$ = coût minimal pour multiplier la chaîne $A_i...A_j$
- Récurrence : $m[i,j] = \min_{i \le k < j} \{ m[i,k] + m[k+1,j] + p_{i-1} \cdot p_k \cdot p_j \}$
- Complexité : O(n³)

## Comparaison Naïf vs PD

| Approche | Fibonacci(40) | Temps |
|----------|---------------|-------|
| Récursion naïve | f(40)=f(39)+f(38) | ~1s |
| PD avec memoïsation | f(40) via memo | ~1ms |
| PD tabulaire | Remplir tableau | ~1ms |

## Recommandations

1. **Identifiez** sous-structure optimale
2. **Définissez** état du sous-problème (dp[i], dp[i][j], etc.)
3. **Écrivez** relation de récurrence
4. **Implémentez** bottom-up (plus rapide) ou top-down (plus lisible)
5. **Optimisez** espace si possible

---

**[↑ Retour à la section 9](README.md)** | **[← Retour à l'index](../INDEX.md)**

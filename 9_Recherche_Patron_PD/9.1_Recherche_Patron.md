# 9.1 Recherche de Patron (Pattern Matching)

## Problématique

Trouver **toutes les occurrences** d'un patron (string) dans un texte.

```
Texte : "ABABDABACDABABCABAB"
Patron : "ABABCAB"

Occurrences : positions 10
              "ABABDABACDABABCABAB"
                         ^(10)
```

**Applications :** Recherche dans éditeur, compression, bioinformatique

## Algorithme Naïf

Comparer le patron à chaque position du texte.

```java
public List<Integer> naiveSearch(String text, String pattern) {
    List<Integer> matches = new ArrayList<>();
    int n = text.length();
    int m = pattern.length();
    
    // Essayer chaque position
    for (int i = 0; i <= n - m; i++) {
        boolean match = true;
        for (int j = 0; j < m; j++) {
            if (text.charAt(i + j) != pattern.charAt(j)) {
                match = false;
                break;
            }
        }
        if (match) {
            matches.add(i);
        }
    }
    
    return matches;
}
```

**Complexité :**
- Meilleur cas : O(n) - patron ne correspond nulle part
- Cas moyen : O(n)
- Pire cas : O(n × m) - ex. texte="AAAA...A", patron="AAAB"

## Algorithme Rabin-Karp

Utiliser un **hash roulant** (rolling hash) pour comparer les patrons en O(1).

### Concept

1. Calculer hash du patron
2. Calculer hash des fenêtres de taille m dans le texte
3. Comparer les hashs (O(1))
4. Si match : vérifier caractère par caractère pour éviter faux positifs

```
Texte : "ABABDAB"
Patron : "ABD"

Fenêtres : "ABA" (h1), "BAB" (h2), "ABD" (h3)
Patron hash : h(ABD)

Si h3 == h(ABD), vérifier "ABD" == "ABD" ✓
```

### Implémentation avec hash polynomial

```java
public List<Integer> rabinKarp(String text, String pattern) {
    List<Integer> matches = new ArrayList<>();
    int n = text.length();
    int m = pattern.length();
    int prime = 101;
    long base = 256;
    long mod = 1000000007;
    
    long patternHash = 0, textHash = 0;
    long pow = 1;
    
    // Calculer pow = base^(m-1) mod
    for (int i = 0; i < m - 1; i++) {
        pow = (pow * base) % mod;
    }
    
    // Calculer hash du patron et première fenêtre
    for (int i = 0; i < m; i++) {
        patternHash = (patternHash * base + pattern.charAt(i)) % mod;
        textHash = (textHash * base + text.charAt(i)) % mod;
    }
    
    // Glisser la fenêtre
    for (int i = 0; i <= n - m; i++) {
        if (patternHash == textHash) {
            // Vérifier match exact (faux positifs possibles)
            if (text.substring(i, i + m).equals(pattern)) {
                matches.add(i);
            }
        }
        
        // Calculer hash de la prochaine fenêtre
        if (i < n - m) {
            textHash = (base * (textHash - text.charAt(i) * pow) 
                       + text.charAt(i + m)) % mod;
            if (textHash < 0) {
                textHash += mod;
            }
        }
    }
    
    return matches;
}
```

**Complexité :**
- Cas moyen : O(n + m) - très peu de faux positifs
- Pire cas : O(n × m) - beaucoup de faux positifs (rare)

**Avantage :** 
- Efficace si faux positifs rares
- Peut être adapté pour **recherche multiple de patrons** simultanément
- Bon choix pour détection de plagiat, recherche de motifs binaires

### Formule récursive de Rabin-Karp

Pour accélérer le calcul du hash des fenêtres successives, on utilise une **formule récursive** :

$$t_{s+1} = \text{mod}((t_s - h \cdot T[s+1]) \cdot d + T[s+m+1], q)$$

où :
- $t_s$ = hash de la fenêtre à position $s$
- $h = \text{mod}(d^{m-1}, q)$ = constante pré-calculée
- $d$ = taille de l'alphabet (ex: 4 pour {A,C,G,T})
- $q$ = nombre premier pour le modulo (ex: 17)
- $m$ = longueur du patron

**Exemple concret** :
- Alphabet : {A=0, C=1, G=2, T=3}, donc $d = 4$
- Patron P[1:4] = "CATA" → hash = mod(((1·4+0)·4+3)·4+0, 17) = mod(76, 17) = 8
- $h = \text{mod}(4^{4-1}, q) = \text{mod}(4^3, 17) = \text{mod}(64, 17) = 13$

Si texte T = "CATAC" :
- $t_0$ = hash("CATA") = 8
- $t_1$ = mod((8 - 13·C)·4 + C, 17) où C=1 (code de 'C')

**Faux positifs** : Deux chaînes différentes peuvent avoir le même hash. Toujours **vérifier caractère par caractère** quand les hashs correspondent.

```java
// Exemple détaillé avec formule récursive
public List<Integer> rabinKarpDetailed(String text, String pattern, int d, int q) {
    List<Integer> matches = new ArrayList<>();
    int n = text.length();
    int m = pattern.length();
    
    // Calculer h = d^(m-1) mod q
    int h = 1;
    for (int i = 0; i < m - 1; i++) {
        h = (h * d) % q;
    }
    
    // Calculer hash du patron et première fenêtre
    int p = 0, t = 0;
    for (int i = 0; i < m; i++) {
        p = (d * p + pattern.charAt(i)) % q;
        t = (d * t + text.charAt(i)) % q;
    }
    
    // Glisser la fenêtre
    for (int s = 0; s <= n - m; s++) {
        if (p == t) {
            // Hash correspond : vérifier pour éviter faux positif
            boolean match = true;
            for (int i = 0; i < m; i++) {
                if (text.charAt(s + i) != pattern.charAt(i)) {
                    match = false;
                    break;
                }
            }
            if (match) {
                matches.add(s);
            }
        }
        
        // Calculer hash de la prochaine fenêtre (formule récursive)
        if (s < n - m) {
            t = (d * (t - text.charAt(s) * h) + text.charAt(s + m)) % q;
            if (t < 0) {
                t += q;  // Assurer t ≥ 0
            }
        }
    }
    
    return matches;
}
```

## Automate Fini (FSM)

Construire un **automate déterministe** qui traite le texte caractère par caractère.

### Concept

1. Créer états représentant les suffixes du patron qui correspondent
2. État i = premiers i caractères du patron trouvés
3. Faire des transitions d'état avec chaque caractère du texte
4. État final = patron trouvé

```
Patron "ABA" :
État 0 : ""          (rien trouvé)
État 1 : "A"         (1 caractère match)
État 2 : "AB"        (2 caractères match)
État 3 : "ABA"       (patron complet trouvé)

Diagramme d'états :
                A         A         A
         0 -----> 1 -----> 2 -----> 3 (acceptation)
         ↑        |  B     |  B     |
         |        ↓        ↓        ↓
         +--------+--------+--------+
              Retour selon préfixe

Transitions avec 'A' et 'B' :
État 0 + 'A' → État 1
État 1 + 'B' → État 2
État 2 + 'A' → État 3 (match!)
État 0 + 'B' → État 0
État 1 + 'A' → État 1 (rester car "AA" commence par "A")
État 2 + 'B' → État 0 (échec, recommencer)
État 3 + 'A' → État 1 (nouveau départ après match)

Tracer texte "ABABABA" :
0 → 1(A) → 2(B) → 3(A)✓ → 1(B→A) → 2(B) → 3(A)✓
        positions 0 et 4
```

### Construction de la table de transitions

Pour construire la table, il faut calculer pour chaque état et chaque caractère la **fonction de transition** :

```java
private void buildFSM(String pattern, int[][] transition) {
    int m = pattern.length();
    
    for (int state = 0; state <= m; state++) {
        for (char c = 0; c < 256; c++) {
            // Trouver le plus long préfixe de pattern qui est suffixe de (pattern[0..state-1] + c)
            transition[state][c] = getNextState(pattern, state, c);
        }
    }
}

private int getNextState(String pattern, int state, char c) {
    // Si on est à l'état final ou le caractère correspond
    if (state < pattern.length() && c == pattern.charAt(state)) {
        return state + 1;
    }
    
    // Sinon, chercher le plus long préfixe
    for (int ns = state; ns > 0; ns--) {
        if (pattern.charAt(ns - 1) == c) {
            boolean match = true;
            for (int i = 0; i < ns - 1; i++) {
                if (pattern.charAt(i) != pattern.charAt(state - ns + 1 + i)) {
                    match = false;
                    break;
                }
            }
            if (match) {
                return ns;
            }
        }
    }
    
    return 0;
}
```

### Table de transitions - Exemple "bonbon"

| État \ Char | b | o | n | Autre |
|-------------|---|---|---|-------|
| 0           | 1 | 0 | 0 | 0     |
| 1           | 1 | 2 | 0 | 0     |
| 2           | 1 | 0 | 3 | 0     |
| 3           | 4 | 0 | 0 | 0     |
| 4           | 1 | 5 | 0 | 0     |
| 5           | 1 | 0 | 6 | 0     |
| 6 (accept)  | 1 | 2 | 0 | 0     |

**États les plus visités** : Dépend du texte. États 0-2 généralement très visités, états finaux moins.

**États les moins visités** : Généralement états finaux (6) et états proches de la fin si le patron est rare.

### Implémentation

```java
public List<Integer> fsmSearch(String text, String pattern) {
    List<Integer> matches = new ArrayList<>();
    int n = text.length();
    int m = pattern.length();
    
    // Construire table de transitions
    // transition[state][char] = next_state
    int[][] transition = new int[m + 1][256];
    
    // Remplir la table via fonction de défaut (KMP-like)
    buildFSM(pattern, transition);
    
    // Tracer le texte
    int state = 0;
    for (int i = 0; i < n; i++) {
        state = transition[state][text.charAt(i)];
        if (state == m) {
            matches.add(i - m + 1);
            state = 0;  // Ou utiliser fonction de défaut
        }
    }
    
    return matches;
}
```

**Complexité :**
- Prétraitement : O(m × σ) où σ = taille alphabet (256)
- Recherche : O(n)
- **Total : O(m × σ + n)** - Optimal quand alphabet fixe!

## Comparaison

| Algorithme | Prétraitement | Recherche | Cas Moyen | Pire Cas |
|-----------|--------------|-----------|-----------|----------|
| Naïf | O(1) | O(n×m) | O(n) | O(n×m) |
| Rabin-Karp | O(m) | O(n) | O(n+m) | O(n×m) |
| FSM | O(m×σ) | O(n) | O(n) | O(n) |

**Recommandations :**
- **Texte court** : Naïf acceptable
- **Recherches multiples** : FSM (σ fixe)
- **Données binaires/compressées** : Rabin-Karp

---

**[↑ Retour à la section 9](README.md)** | **[← Retour à l'index](../INDEX.md)**

# 9.1 Recherche de Patron (Pattern Matching)

## Problématique

Trouver **toutes les occurrences** d'un patron (string) dans un texte.

```
Texte : "ABABDABACDABABCABAB"
Patron : "ABABCAB"

Occurrences : positions 9 et 12
              "ABABDABACDABABCABAB"
                       ^(9)
                          ^(12)
```

**Applications :** Recherche dans éditeur, compression, bioinformatique

## Algorithme Naïf

Comparer le patron à chaque position du texte.

```java
public List<Integer> naiveSearch(String text, String pattern) {
    List<Integer> matches = new ArrayList<>();
    int n = text.length();
    int m = pattern.length();
    
    // Essayer chaque position
    for (int i = 0; i <= n - m; i++) {
        boolean match = true;
        for (int j = 0; j < m; j++) {
            if (text.charAt(i + j) != pattern.charAt(j)) {
                match = false;
                break;
            }
        }
        if (match) {
            matches.add(i);
        }
    }
    
    return matches;
}
```

**Complexité :**
- Meilleur cas : O(n) - patron ne correspond nulle part
- Cas moyen : O(n)
- Pire cas : O(n × m) - ex. texte="AAAA...A", patron="AAAB"

## Algorithme Rabin-Karp

Utiliser un **hash roulant** (rolling hash) pour comparer les patrons en O(1).

### Concept

1. Calculer hash du patron
2. Calculer hash des fenêtres de taille m dans le texte
3. Comparer les hashs (O(1))
4. Si match : vérifier caractère par caractère pour éviter faux positifs

```
Texte : "ABABDAB"
Patron : "ABD"

Fenêtres : "ABA" (h1), "BAB" (h2), "ABD" (h3)
Patron hash : h(ABD)

Si h3 == h(ABD), vérifier "ABD" == "ABD" ✓
```

### Implémentation avec hash polynomial

```java
public List<Integer> rabinKarp(String text, String pattern) {
    List<Integer> matches = new ArrayList<>();
    int n = text.length();
    int m = pattern.length();
    int prime = 101;
    long base = 256;
    long mod = 1000000007;
    
    long patternHash = 0, textHash = 0;
    long pow = 1;
    
    // Calculer pow = base^(m-1) mod
    for (int i = 0; i < m - 1; i++) {
        pow = (pow * base) % mod;
    }
    
    // Calculer hash du patron et première fenêtre
    for (int i = 0; i < m; i++) {
        patternHash = (patternHash * base + pattern.charAt(i)) % mod;
        textHash = (textHash * base + text.charAt(i)) % mod;
    }
    
    // Glisser la fenêtre
    for (int i = 0; i <= n - m; i++) {
        if (patternHash == textHash) {
            // Vérifier match exact (faux positifs possibles)
            if (text.substring(i, i + m).equals(pattern)) {
                matches.add(i);
            }
        }
        
        // Calculer hash de la prochaine fenêtre
        if (i < n - m) {
            textHash = (base * (textHash - text.charAt(i) * pow) 
                       + text.charAt(i + m)) % mod;
            if (textHash < 0) {
                textHash += mod;
            }
        }
    }
    
    return matches;
}
```

**Complexité :**
- Cas moyen : O(n + m) - très peu de faux positifs
- Pire cas : O(n × m) - beaucoup de faux positifs (rare)

**Avantage :** 
- Efficace si faux positifs rares
- Peut être adapté pour **recherche multiple de patrons** simultanément
- Bon choix pour détection de plagiat, recherche de motifs binaires

## Automate Fini (FSM)

Construire un **automate déterministe** qui traite le texte caractère par caractère.

### Concept

1. Créer états représentant les suffixes du patron qui correspondent
2. État i = premiers i caractères du patron trouvés
3. Faire des transitions d'état avec chaque caractère du texte
4. État final = patron trouvé

```
Patron "ABA" :
État 0 : ""
État 1 : "A"
État 2 : "AB"
État 3 : "ABA" (match)

Transitions avec 'A' et 'B' :
État 0 + 'A' → État 1
État 1 + 'B' → État 2
État 2 + 'A' → État 3
État 0 + 'B' → État 0
etc.

Tracer texte "ABABABA" :
0 → 1(A) → 2(B) → 3(A)✓ → 1(B→A) → 2(B) → 3(A)✓
        positions 0 et 4
```

### Implémentation

```java
public List<Integer> fsmSearch(String text, String pattern) {
    List<Integer> matches = new ArrayList<>();
    int n = text.length();
    int m = pattern.length();
    
    // Construire table de transitions
    // transition[state][char] = next_state
    int[][] transition = new int[m + 1][256];
    
    // Remplir la table via fonction de défaut (KMP-like)
    buildFSM(pattern, transition);
    
    // Tracer le texte
    int state = 0;
    for (int i = 0; i < n; i++) {
        state = transition[state][text.charAt(i)];
        if (state == m) {
            matches.add(i - m + 1);
            state = 0;  // Ou utiliser fonction de défaut
        }
    }
    
    return matches;
}
```

**Complexité :**
- Prétraitement : O(m × σ) où σ = taille alphabet (256)
- Recherche : O(n)
- **Total : O(m × σ + n)** - Optimal quand alphabet fixe!

## Comparaison

| Algorithme | Prétraitement | Recherche | Cas Moyen | Pire Cas |
|-----------|--------------|-----------|-----------|----------|
| Naïf | O(1) | O(n×m) | O(n) | O(n×m) |
| Rabin-Karp | O(m) | O(n) | O(n+m) | O(n×m) |
| FSM | O(m×σ) | O(n) | O(n) | O(n) |

**Recommandations :**
- **Texte court** : Naïf acceptable
- **Recherches multiples** : FSM (σ fixe)
- **Données binaires/compressées** : Rabin-Karp

---

**[↑ Retour à la section 9](README.md)** | **[← Retour à l'index](../INDEX.md)**

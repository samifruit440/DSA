# 5.3 Arbres Binaires de Recherche (ABR)

## Propriété des ABR

Un **Arbre Binaire de Recherche (ABR)** satisfait :
- **Sous-arbre gauche < Nœud < Sous-arbre droit**
- Tous les nœuds du sous-arbre gauche sont < au nœud
- Tous les nœuds du sous-arbre droit sont > au nœud

```
Valide :          7          Invalide :      7
                 / \                        / \
                /   \                      /   \
               3     9                    9     3  (droite < gauche!)
              / \   / \                  / \   / \
             1  5  8  11                1  5  8  11
```

**Propriété importante :** Un parcours **in-ordre** d'un ABR produit les éléments en **ordre croissant**.

## Opérations

### Recherche

Comparer la clé avec le nœud actuel et descendre à gauche ou droite.

```java
public TreeNode search(TreeNode node, int key) {
    if (node == null) return null;
    
    if (key < node.value) {
        return search(node.left, key);
    } else if (key > node.value) {
        return search(node.right, key);
    } else {
        return node;  // Trouvé !
    }
}
```

**Complexité :**
- **Meilleur cas** : O(1) - racine
- **Cas moyen** : O(log N) - ABR équilibré
- **Pire cas** : O(N) - ABR dégénéré en liste chaînée

### Insertion

Toujours insérer à une **feuille**. Parcourir l'arbre jusqu'à trouver la position.

```java
public TreeNode insert(TreeNode node, int value) {
    if (node == null) {
        return new TreeNode(value);  // Créer feuille
    }
    
    if (value < node.value) {
        node.left = insert(node.left, value);
    } else if (value > node.value) {
        node.right = insert(node.right, value);
    }
    // Sinon : doublon, ne rien faire
    
    return node;
}

// Utilisation
root = insert(root, 7);
root = insert(root, 3);
root = insert(root, 9);
```

**Complexité :** O(log N) moyen, O(N) pire cas

### Suppression

Trois cas selon le nombre d'enfants du nœud à supprimer.

#### Cas 1 : Nœud sans enfant (feuille)

Simplement retirer le nœud.

```
Avant :   7          Après :   7
         / \                  / \
        3   9                3   11
         \   \
          5  11

Supprimer 5 : simple!
```

#### Cas 2 : Nœud avec un enfant

Remplacer le nœud par son enfant.

```
Avant :   7          Après :   7
         / \                  / \
        3   9                5   9
         \
          5

Supprimer 3 : remplacer par 5
```

#### Cas 3 : Nœud avec deux enfants

Trouver le **prédécesseur inorder** (max du sous-arbre gauche) ou le **successeur inorder** (min du sous-arbre droit), remplacer la valeur, puis supprimer.

```
Avant :   7          Après :   7
         / \                  / \
        3   9                5   9
       / \
      1   5

Supprimer 3 : 
  - Successeur inorder de 3 = 5
  - Remplacer 3 par 5
  - Supprimer 5 du sous-arbre droit
```

```java
public TreeNode delete(TreeNode node, int value) {
    if (node == null) return null;
    
    if (value < node.value) {
        node.left = delete(node.left, value);
    } else if (value > node.value) {
        node.right = delete(node.right, value);
    } else {
        // Nœud à supprimer trouvé
        
        // Cas 1 : Pas d'enfant
        if (node.left == null && node.right == null) {
            return null;
        }
        
        // Cas 2 : Un enfant
        if (node.left == null) return node.right;
        if (node.right == null) return node.left;
        
        // Cas 3 : Deux enfants
        // Trouver le successeur inorder (min du sous-arbre droit)
        TreeNode successor = findMin(node.right);
        node.value = successor.value;
        node.right = delete(node.right, successor.value);
    }
    
    return node;
}

private TreeNode findMin(TreeNode node) {
    while (node.left != null) {
        node = node.left;
    }
    return node;
}
```

## Problème de dégénération

Si l'ordre d'insertion est mauvais, l'ABR peut dégénérer en **liste chaînée** !

```
Insertion : 1, 2, 3, 4, 5

Résultat (liste !) :
    1
     \
      2
       \
        3
         \
          4
           \
            5

Recherche : O(N) au lieu de O(log N) !
```

### Solution

Utiliser un **ABR équilibré** (AVL, Red-Black) ou réequilibrer après insertions.

## Résumé

| Opération | Cas moyen | Pire cas | Notes |
|-----------|-----------|----------|-------|
| Recherche | O(log N) | O(N) | Équilibré vs dégénéré |
| Insertion | O(log N) | O(N) | Toujours à une feuille |
| Suppression | O(log N) | O(N) | 3 cas à gérer |
| In-ordre | O(N) | O(N) | Donne ordre croissant |

---

**[↑ Retour à la section 5](README.md)** | **[← Retour à l'index](../INDEX.md)**

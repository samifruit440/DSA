# 5.1 Arbres Binaires : Définitions et Représentations

## Définitions

### Définition non-récursive

Un **arbre** est une collection de nœuds et d'arêtes connectées :
- Exactement un **nœud racine** (pas de parent)
- Chaque autre nœud a exactement **un parent**
- **Chemin unique** entre la racine et tout nœud
- **Pas de cycles**

### Définition récursive

Un arbre est :
- Un nœud seul (racine), ou
- Un nœud avec zéro ou plusieurs **sous-arbres**

## Terminologie

- **Racine** : Nœud sans parent (niveau 0)
- **Feuille** : Nœud sans enfants
- **Degré** : Nombre d'enfants d'un nœud
- **Niveau** : Distance de la racine (racine = niveau 0)
- **Hauteur** : Nombre maximum d'arêtes de la racine à une feuille
- **Arbre complet** : Tous les niveaux sauf le dernier sont complètement remplis

## Arbre Binaire

### Concept

Un **arbre binaire** est un arbre où chaque nœud a **au maximum 2 enfants** :
- **Enfant gauche**
- **Enfant droit**

```
        1
       / \
      2   3
     / \
    4   5
```

### Propriétés

- Nombre maximum de nœuds au niveau k : 2^k
- Nombre maximum de nœuds dans un arbre de hauteur h : 2^(h+1) - 1
- Un arbre binaire complet de hauteur h a 2^(h+1) - 1 nœuds

## Représentations

### Représentation par pointeurs (dynamique)

Chaque nœud contient la valeur et des pointeurs vers les enfants.

```java
public class TreeNode {
    int value;
    TreeNode left;
    TreeNode right;
    
    public TreeNode(int value) {
        this.value = value;
    }
}

// Création
TreeNode root = new TreeNode(1);
root.left = new TreeNode(2);
root.right = new TreeNode(3);
root.left.left = new TreeNode(4);
```

**Avantages :**
- Flexible, permet les arbres non équilibrés
- Pas d'espace gaspillé pour nœuds manquants

**Inconvénients :**
- Surcharge mémoire pour pointeurs
- Pas d'accès direct par indice

### Représentation par tableau séquentiel

Les nœuds sont stockés dans un tableau avec une indexation spéciale.

**Formules :**
- Parent du nœud i : i / 2
- Enfant gauche du nœud i : 2i
- Enfant droit du nœud i : 2i + 1

```
Index :     1   2   3   4   5   6   7
Valeur :   [1] [2] [3] [4] [5][ ][ ]

Arbre :
        1 (index 1)
       / \
      2   3  (index 2, 3)
     / \
    4   5   (index 4, 5)
```

```java
// Implémentation
public class ArrayBinaryTree {
    private int[] tree;
    private int size;
    
    public ArrayBinaryTree(int capacity) {
        tree = new int[capacity + 1]; // Index commence à 1
        size = 0;
    }
    
    public void insert(int index, int value) {
        tree[index] = value;
        size++;
    }
    
    public int getParent(int index) {
        return index / 2;
    }
    
    public int getLeftChild(int index) {
        return 2 * index;
    }
    
    public int getRightChild(int index) {
        return 2 * index + 1;
    }
}
```

**Avantages :**
- Accès efficace à parent/enfants
- Pas de pointeurs
- Bon pour arbres complets/presque complets

**Inconvénients :**
- Espace gaspillé si arbre non équilibré
- Difficulté pour arbres peu denses

## Comparaison

| Aspect | Pointeurs | Tableau |
|--------|-----------|---------|
| Accès parent/enfant | O(1) pointeur | O(1) calcul |
| Mémoire - arbre complet | Efficace | Efficace |
| Mémoire - arbre déséquilibré | Bon | Mauvais |
| Insertion dynamique | Facile | Complexe |
| Cache | Moyen | Bon |

---

**[↑ Retour à la section 5](README.md)** | **[← Retour à l'index](../INDEX.md)**

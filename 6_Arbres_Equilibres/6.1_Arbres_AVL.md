# 6.1 Arbres AVL

## Concept de base

Un **arbre AVL (Adelson-Velsky-Landis)** est un ABR **auto-√©quilibrant** o√π :
- Pour chaque n≈ìud, la hauteur du sous-arbre gauche et droit **diff√®re d'au plus 1**
- Le **facteur d'√©quilibre** = hauteur(gauche) - hauteur(droite) ‚àà {-1, 0, 1}

```
Valide (AVL) :                     Invalide :
      5                                  5
     / \                                / \
    3   7                              3   7
   /   / \                            /   / \
  2   6   8                          1   6   8
                                    /
                                   0
  
  Facteurs d'√©quilibre : OK    Facteurs : KO (facteur(5) = 2)
```

## Propri√©t√© de hauteur - O(log N) garanti

**La cl√© :** Un AVL reste **√©quilibr√©**, donc la hauteur reste petite.

Imagine une arbre binaire avec 1 milliard de n≈ìuds. Si c'√©tait mal √©quilibr√©, tu pourrais devoir descendre jusqu'au fond = milliard d'√©tapes. Mais un AVL s'auto-√©quilibre pour rester "bushy" pas "skinny".

```
Mal √©quilibr√© :    Bien √©quilibr√© (AVL) :
    1                       8
     \                    /   \
      2                  4     12
       \                / \    / \
        3              2   6  10  14
         \            / \ / \
          ...        1  3 5  7
                        
Chercher 1000 : Chercher 1000 :
1000 √©tapes     ~10 √©tapes
```

### La garantie math√©matique (simplifi√©)

Pour **N = 1 million de n≈ìuds** :
- ABR mal √©quilibr√© : jusqu'√† 1 million d'√©tapes üò±
- AVL bien √©quilibr√© : seulement **log‚ÇÇ(1,000,000) ‚âà 20 √©tapes** ‚úì

**Formule exacte** : $h \leq 1.44 \log_2(N)$

Cela signifie : hauteur ‚âà 1.44 √ó (nombre de fois qu'on peut diviser N par 2)

```
N = 8 n≈ìuds   ‚Üí log‚ÇÇ(8) = 3       ‚Üí hauteur ‚â§ 4.32 (r√©alit√© : 3)
N = 1000      ‚Üí log‚ÇÇ(1000) = 10   ‚Üí hauteur ‚â§ 14.4
N = 1 million ‚Üí log‚ÇÇ(1M) = 20     ‚Üí hauteur ‚â§ 28.8
```

**Cons√©quence** : Les op√©rations (recherche, insertion, suppression) sont **O(log N)** car on descend dans l'arbre une fois.

## R√©√©quilibrage par rotations

Apr√®s insertion ou suppression, si un n≈ìud devient d√©s√©quilibr√© (facteur ‚â† {-1, 0, 1}), effectuer une rotation.

### Rotation simple (cas Gauche-Gauche ou Droite-Droite)

#### Cas Gauche-Gauche (LL)

D√©s√©quilibre caus√© par insertion dans le sous-arbre gauche du fils gauche.

```
Avant rotation :     Apr√®s rotation droite :
       z                  y
      / \                / \
     y   T4             x   z
    / \          ‚Üí     / \ / \
   x  T3             T1 T2 T3 T4
  / \
 T1 T2
```

```java
public TreeNode rotateRight(TreeNode z) {
    TreeNode y = z.left;
    TreeNode T3 = y.right;
    
    y.right = z;
    z.left = T3;
    
    return y;
}
```

#### Cas Droite-Droite (RR)

D√©s√©quilibre caus√© par insertion dans le sous-arbre droit du fils droit.

```
Avant rotation :     Apr√®s rotation gauche :
    x                      y
   / \                    / \
  T1  y          ‚Üí       x   z
     / \                / \ / \
    T2  z             T1 T2 T3 T4
       / \
      T3 T4
```

```java
public TreeNode rotateLeft(TreeNode x) {
    TreeNode y = x.right;
    TreeNode T2 = y.left;
    
    y.left = x;
    x.right = T2;
    
    return y;
}
```

### Rotation double (cas Gauche-Droite ou Droite-Gauche)

#### Cas Gauche-Droite (LR)

D√©s√©quilibre : insertion dans sous-arbre droit du fils gauche.

**√âtapes** :
1. Rotation **gauche** sur le fils gauche (x)
2. Rotation **droite** sur le p√®re (z)

```
Avant :          z                  √âtape 1 - Rotation gauche sur x :
                / \                            z
               x   T4                         / \
              / \          ‚Üí                 y   T4
            T1   y                          / \
                / \                        x   T3
              T2   T3                     / \
                                        T1   T2

√âtape 2 - Rotation droite sur z :
                 y
                / \
               x   z
              / \ / \
            T1 T2 T3 T4
```

```java
public TreeNode rotateLeftRight(TreeNode z) {
    z.left = rotateLeft(z.left);      // √âtape 1 : rotation gauche sur x
    return rotateRight(z);             // √âtape 2 : rotation droite sur z
}
```

#### Cas Droite-Gauche (RL)

D√©s√©quilibre : insertion dans sous-arbre gauche du fils droit.

**√âtapes** :
1. Rotation **droite** sur le fils droit (z)
2. Rotation **gauche** sur le p√®re (x)

```
Avant :          x                  √âtape 1 - Rotation droite sur z :
                / \                            x
              T1   z                          / \
                  / \        ‚Üí              T1   y
                 y   T4                         / \
                / \                           T2   z
              T2   T3                             / \
                                                T3   T4

√âtape 2 - Rotation gauche sur x :
                 y
                / \
               x   z
              / \ / \
            T1 T2 T3 T4
```

```java
public TreeNode rotateRightLeft(TreeNode z) {
    z.right = rotateRight(z.right);    // √âtape 1 : rotation droite sur z
    return rotateLeft(z);              // √âtape 2 : rotation gauche sur x
}
```

## Insertion avec r√©√©quilibrage

```java
public TreeNode insert(TreeNode node, int value) {
    if (node == null) return new TreeNode(value);
    
    if (value < node.value) {
        node.left = insert(node.left, value);
    } else if (value > node.value) {
        node.right = insert(node.right, value);
    } else {
        return node;  // Doublon
    }
    
    // Mettre √† jour hauteur
    node.height = 1 + Math.max(getHeight(node.left), getHeight(node.right));
    
    // Calculer facteur d'√©quilibre et effectuer rotations si n√©cessaire
    int balance = getBalance(node);
    
    // Cas LL
    if (balance > 1 && value < node.left.value) {
        return rotateRight(node);
    }
    
    // Cas RR
    if (balance < -1 && value > node.right.value) {
        return rotateLeft(node);
    }
    
    // Cas LR
    if (balance > 1 && value > node.left.value) {
        node.left = rotateLeft(node.left);
        return rotateRight(node);
    }
    
    // Cas RL
    if (balance < -1 && value < node.right.value) {
        node.right = rotateRight(node.right);
        return rotateLeft(node);
    }
    
    return node;
}

private int getBalance(TreeNode node) {
    return node == null ? 0 : getHeight(node.left) - getHeight(node.right);
}

private int getHeight(TreeNode node) {
    return node == null ? -1 : node.height;
}
```

## Complexit√© et Garanties

| Op√©ration | Complexit√© | Garantie |
|-----------|-----------|----------|
| Recherche | O(log N) | ‚úì Pire cas garanti |
| Insertion | O(log N) | ‚úì Pire cas garanti |
| Suppression | O(log N) | ‚úì Pire cas garanti |
| R√©√©quilibrage | O(log N) | Au plus 1 rotation (insertion), O(log N) rotations (suppression) |

**Note importante** : L'insertion n√©cessite **au plus 1 rotation** (simple ou double), tandis que la suppression peut n√©cessiter jusqu'√† O(log N) rotations en cascade le long du chemin vers la racine.

## Suppression dans AVL

La suppression suit le m√™me algorithme qu'un ABR standard (3 cas), mais avec r√©√©quilibrage apr√®s:

```java
public TreeNode delete(TreeNode node, int value) {
    if (node == null) return null;
    
    // Recherche du n≈ìud √† supprimer
    if (value < node.value) {
        node.left = delete(node.left, value);
    } else if (value > node.value) {
        node.right = delete(node.right, value);
    } else {
        // Cas 1 & 2: 0 ou 1 enfant
        if (node.left == null) return node.right;
        if (node.right == null) return node.left;
        
        // Cas 3: 2 enfants - remplacer par successeur
        TreeNode successor = findMin(node.right);
        node.value = successor.value;
        node.right = delete(node.right, successor.value);
    }
    
    // Mettre √† jour hauteur et r√©√©quilibrer
    node.height = 1 + Math.max(getHeight(node.left), getHeight(node.right));
    int balance = getBalance(node);
    
    // M√™me logique de rotation qu'insertion
    if (balance > 1 && getBalance(node.left) >= 0) return rotateRight(node);
    if (balance < -1 && getBalance(node.right) <= 0) return rotateLeft(node);
    if (balance > 1 && getBalance(node.left) < 0) {
        node.left = rotateLeft(node.left);
        return rotateRight(node);
    }
    if (balance < -1 && getBalance(node.right) > 0) {
        node.right = rotateRight(node.right);
        return rotateLeft(node);
    }
    
    return node;
}
```

---

**[‚Üë Retour √† la section 6](README.md)** | **[‚Üê Retour √† l'index](../INDEX.md)**

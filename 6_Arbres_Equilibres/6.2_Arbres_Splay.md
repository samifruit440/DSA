# 6.2 Arbres Splay

## Concept de base

Un **arbre Splay** est un ABR auto-ajustant sans contrainte d'équilibre explicite. Lors d'un accès, le nœud est déplacé à la racine via des **splaying**.

**Propriété importante :** Complexité **amortie** de O(log N) pour une séquence d'opérations. Une opération individuelle peut être O(N).

## Splaying

Après chaque accès (recherche, insertion, suppression), le nœud accédé devient la nouvelle **racine** via une série de rotations appelées **splay**.

### Types de rotations Splay

#### Zig (rotation simple)

Le nœud x est **fils direct** de la racine → rotation simple.

```
Zig gauche (x est fils gauche) :

    racine                x
     /  \                / \
    x    C      →       A   racine
   / \                     / \
  A   B                   B   C

Zig droite (x est fils droit) :

    racine                x
     /  \                / \
    A    x      →    racine  C
        / \           / \
       B   C         A   B
```

#### Zig-Zig (même direction)

Le nœud x est **petit-fils dans la même direction** (gauche-gauche ou droite-droite).

**Important** : Rotation du **grand-parent d'abord**, puis du parent.

```
Zig-Zig gauche-gauche :

Avant :          Étape 1 - Rotation droite sur gp :      Étape 2 - Rotation droite sur p :
    gp                       p                                    x
   /  \                     / \                                  / \
  p    D                   x   gp                               A   p
 / \          →           / \ / \              →                   / \
x   C                    A  B C  D                                B   gp
/ \                                                                   / \
A  B                                                                 C   D

Zig-Zig droite-droite :

Avant :          Étape 1 - Rotation gauche sur gp :     Étape 2 - Rotation gauche sur p :
  gp                         p                                    x
 /  \                       / \                                  / \
A    p                    gp   x                                p   D
    / \        →         / \ / \              →                / \
   B   x                A  B C  D                             gp  C
      / \                                                     / \
     C   D                                                   A   B
```

#### Zig-Zag (directions opposées)

Le nœud x est **petit-fils en zigzag** (gauche-droite ou droite-gauche).

**Important** : Comme une rotation double AVL - rotation sur x deux fois.

```
Zig-Zag gauche-droite :

Avant :          Étape 1 - Rotation gauche sur p :      Étape 2 - Rotation droite sur gp :
    gp                       gp                                    x
   /  \                     /  \                                  / \
  p    D                   x    D                                p   gp
 / \          →           / \              →                    / \ / \
A   x                    p   C                                 A  B C  D
   / \                  / \
  B   C                A   B

Zig-Zag droite-gauche :

Avant :          Étape 1 - Rotation droite sur p :      Étape 2 - Rotation gauche sur gp :
  gp                         gp                                    x
 /  \                       /  \                                  / \
A    p                     A    x                               gp   p
    / \        →               / \              →              / \ / \
   x   D                      B   p                           A  B C  D
  / \                            / \
 B   C                          C   D
```

## Implémentation Top-Down

```java
public TreeNode splay(TreeNode root, int value) {
    if (root == null) return null;
    
    if (value < root.value) {
        if (root.left == null) return root;  // Zig
        
        if (value < root.left.value) {
            // Zig-Zig (gauche-gauche)
            root.left.left = splay(root.left.left, value);
            root = rotateRight(root);
        } else {
            // Zig-Zag (gauche-droit)
            root.left.right = splay(root.left.right, value);
            root.left = rotateLeft(root.left);
        }
        
        return rotateRight(root);
    } else if (value > root.value) {
        if (root.right == null) return root;  // Zig
        
        if (value > root.right.value) {
            // Zig-Zig (droite-droite)
            root.right.right = splay(root.right.right, value);
            root = rotateLeft(root);
        } else {
            // Zig-Zag (droite-gauche)
            root.right.left = splay(root.right.left, value);
            root.right = rotateRight(root.right);
        }
        
        return rotateLeft(root);
    } else {
        return root;  // Trouvé, déjà à la racine
    }
}
```

## Avantages et inconvénients

### Avantages

✓ **Localité** : Les éléments fréquemment accédés remontent à la racine → **cache friendly**

✓ **Pas de métadonnées** : Pas besoin de stocker les hauteurs comme en AVL

✓ **Performance adaptive** : S'adapte aux patterns d'accès

✓ **Amortie O(log N)** : Même sans équilibre strict

### Inconvénients

✗ **Opération individuelle O(N)** : Une seule opération peut être très coûteuse

✗ **Moins prévisible** : AVL garantit O(log N) au pire cas

✗ **Complexe** : Plus difficile à implémenter et debugger

## Comparaison AVL vs Splay

| Aspect | AVL | Splay |
|--------|-----|-------|
| Pire cas recherche | O(log N) | O(N) |
| Amortie | O(log N) | O(log N) |
| Complexité | Équilibre garanti | Amortie |
| Métadonnées | Hauteur | Aucune |
| Cache | Moyen | ✓ Bon |
| Localité | Ignorée | ✓ Exploitée |
| Implémentation | Modérée | Complexe |

**Recommandation :** 
- **AVL** : Accès uniform, garantie pire cas important
- **Splay** : Accès localisé, patterns répétitifs

---

**[↑ Retour à la section 6](README.md)** | **[← Retour à l'index](../INDEX.md)**

# 4.2 Tris Simples (O(n²))

Les tris simples sont faciles à comprendre mais inefficaces sur de grandes données.

## Tri par sélection (Selection Sort)

### Concept

À chaque étape, trouver l'élément minimum de la partie non triée et le placer au début.

```
Itération 1 : [3, 1, 4, 2]  → [1, 3, 4, 2]  (1 est le min)
Itération 2 : [1, 3, 4, 2]  → [1, 2, 3, 4]  (2 est le min de [3,4,2])
Itération 3 : [1, 2, 3, 4]  → [1, 2, 3, 4]  (3 est le min de [3,4])
```

### Implémentation

```java
public static void selectionSort(int[] arr) {
    int n = arr.length;
    for (int i = 0; i < n - 1; i++) {
        int minIdx = i;
        for (int j = i + 1; j < n; j++) {
            if (arr[j] < arr[minIdx]) {
                minIdx = j;
            }
        }
        // Échanger
        int temp = arr[i];
        arr[i] = arr[minIdx];
        arr[minIdx] = temp;
    }
}
```

### Complexité

- **Meilleur cas** : O(n²) - même avec données triées, on cherche les minima
- **Cas moyen** : O(n²)
- **Pire cas** : O(n²)
- **Mémoire** : O(1) - tri en place

## Tri en bulle (Bubble Sort)

### Concept

Comparer les éléments adjacents et les échanger s'ils sont mal ordonnés. Répéter jusqu'à ce qu'aucun échange ne soit nécessaire.

```
Passe 1 : [3, 1, 4, 2] → [1, 3, 2, 4]  (4 remonte)
Passe 2 : [1, 3, 2, 4] → [1, 2, 3, 4]  (3 remonte)
Passe 3 : [1, 2, 3, 4] → [1, 2, 3, 4]  (pas d'échange, stop)
```

### Implémentation

```java
public static void bubbleSort(int[] arr) {
    int n = arr.length;
    for (int i = 0; i < n - 1; i++) {
        boolean swapped = false;
        for (int j = 0; j < n - i - 1; j++) {
            if (arr[j] > arr[j + 1]) {
                // Échanger
                int temp = arr[j];
                arr[j] = arr[j + 1];
                arr[j + 1] = temp;
                swapped = true;
            }
        }
        if (!swapped) break; // Optimisation
    }
}
```

### Complexité

- **Meilleur cas** : O(n) - avec optimisation, si données déjà triées
- **Cas moyen** : O(n²)
- **Pire cas** : O(n²)
- **Mémoire** : O(1) - tri en place

## Tri par insertion (Insertion Sort)

### Concept

Construire progressivement un sous-tableau trié. À chaque étape, prendre l'élément suivant et l'insérer à sa bonne position.

```
Étape 1 : [3] | 1, 4, 2     → [1, 3] | 4, 2
Étape 2 : [1, 3] | 4, 2     → [1, 3, 4] | 2
Étape 3 : [1, 3, 4] | 2     → [1, 2, 3, 4]
```

### Implémentation

```java
public static void insertionSort(int[] arr) {
    for (int i = 1; i < arr.length; i++) {
        int key = arr[i];
        int j = i - 1;
        while (j >= 0 && arr[j] > key) {
            arr[j + 1] = arr[j];
            j--;
        }
        arr[j + 1] = key;
    }
}
```

### Complexité

- **Meilleur cas** : O(n) - données déjà triées
- **Cas moyen** : O(n²)
- **Pire cas** : O(n²) - données inversement triées
- **Mémoire** : O(1) - tri en place
- **Stabilité** : ✓ Stable

### Avantage

Insertion Sort est très efficace sur **petits tableaux** (< 50 éléments) et sur données **partiellement triées**.

## Comparaison des tris simples

| Tri | Meilleur | Moyen | Pire | Mémoire | Stable |
|-----|----------|-------|------|---------|--------|
| Sélection | O(n²) | O(n²) | O(n²) | O(1) | ✗ |
| Bulle | O(n) | O(n²) | O(n²) | O(1) | ✓ |
| Insertion | O(n) | O(n²) | O(n²) | O(1) | ✓ |

### Recommandation

- **Petits tableaux** (< 50 éléments) : Insertion Sort
- **Données partiellement triées** : Insertion Sort
- **Simplicité** : Bubble Sort (pédagogique)
- **Général** : Ne pas utiliser, préférer MergeSort ou QuickSort

---

**[↑ Retour à la section 4](README.md)** | **[← Retour à l'index](../INDEX.md)**

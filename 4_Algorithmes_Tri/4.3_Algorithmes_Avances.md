# 4.3 Algorithmes Avancés (O(N log N))

Les algorithmes avancés utilisent la stratégie **diviser pour régner** pour obtenir une meilleure complexité.

## MergeSort (Tri par fusion)

### Concept

**Diviser** le tableau en deux, **trier** récursivement chaque moitié, puis **fusionner** les résultats.

```
[5, 2, 8, 1, 9]
        ↓
    [5, 2] [8, 1, 9]
        ↓
    [5] [2] [8] [1, 9]
        ↓
    [2, 5] [1, 8, 9]
        ↓
    [1, 2, 5, 8, 9]
```

### Implémentation

```java
public static void mergeSort(int[] arr, int left, int right) {
    if (left < right) {
        int mid = left + (right - left) / 2;
        mergeSort(arr, left, mid);      // Trier gauche
        mergeSort(arr, mid + 1, right); // Trier droite
        merge(arr, left, mid, right);   // Fusionner
    }
}

private static void merge(int[] arr, int left, int mid, int right) {
    int n1 = mid - left + 1;
    int n2 = right - mid;
    
    int[] leftArr = new int[n1];
    int[] rightArr = new int[n2];
    
    System.arraycopy(arr, left, leftArr, 0, n1);
    System.arraycopy(arr, mid + 1, rightArr, 0, n2);
    
    int i = 0, j = 0, k = left;
    while (i < n1 && j < n2) {
        if (leftArr[i] <= rightArr[j]) {
            arr[k++] = leftArr[i++];
        } else {
            arr[k++] = rightArr[j++];
        }
    }
    
    while (i < n1) arr[k++] = leftArr[i++];
    while (j < n2) arr[k++] = rightArr[j++];
}
```

### Complexité

- **Meilleur cas** : O(N log N)
- **Cas moyen** : O(N log N)
- **Pire cas** : O(N log N) - **Garanti !**
- **Mémoire** : O(N) - fusion nécessite espace temporaire
- **Stabilité** : ✓ Stable

### Avantages et inconvénients

**Avantages :**
- Complexité garantie O(N log N)
- Stable
- Bon pour données externes (disque)

**Inconvénients :**
- Mémoire supplémentaire O(N)
- Plus lent que QuickSort en moyenne sur données petites

## QuickSort (Tri rapide)

### Concept

Choisir un **pivot**, **partitionner** le tableau autour du pivot, puis **trier** récursivement les partitions.

```
[5, 2, 8, 1, 9] pivot = 5
        ↓
[2, 1] [5] [8, 9]
        ↓
[1, 2] [5] [8, 9]
        ↓
[1, 2, 5, 8, 9]
```

### Implémentation

```java
public static void quickSort(int[] arr, int low, int high) {
    if (low < high) {
        int pi = partition(arr, low, high);
        quickSort(arr, low, pi - 1);
        quickSort(arr, pi + 1, high);
    }
}

private static int partition(int[] arr, int low, int high) {
    int pivot = arr[high];
    int i = low - 1;
    
    for (int j = low; j < high; j++) {
        if (arr[j] < pivot) {
            i++;
            // Échanger
            int temp = arr[i];
            arr[i] = arr[j];
            arr[j] = temp;
        }
    }
    
    // Échanger pivot avec élément en i+1
    int temp = arr[i + 1];
    arr[i + 1] = arr[high];
    arr[high] = temp;
    
    return i + 1;
}
```

### Sélection du pivot

La qualité du pivot affecte les performances :

- **Pivot aléatoire** : Bon en moyenne
- **Pivot médian-de-trois** : Choisir la médiane de (premier, milieu, dernier)

```java
private static int median3(int[] arr, int low, int high) {
    int mid = low + (high - low) / 2;
    if (arr[low] > arr[mid]) swap(arr, low, mid);
    if (arr[low] > arr[high]) swap(arr, low, high);
    if (arr[mid] > arr[high]) swap(arr, mid, high);
    return arr[mid];
}
```

### Complexité

- **Meilleur cas** : O(N log N) - pivot équilibre bien
- **Cas moyen** : O(N log N) - généralement très rapide
- **Pire cas** : O(n²) - pivot toujours min ou max
- **Mémoire** : O(log N) - pile de récursion
- **Stabilité** : ✗ Instable

### Avantages et inconvénients

**Avantages :**
- Très rapide en pratique (cache-friendly)
- Tri en place
- Espace mémoire minimal

**Inconvénients :**
- Complexité pire cas O(n²)
- Instable
- Sensible au choix du pivot

### Complexité

- **Meilleur et cas moyen** : O(N) - amorti
- **Pire cas** : O(N²)
- **Mémoire** : O(log N)

## Comparaison des tris avancés

| Algorithme | Meilleur | Moyen | Pire | Mémoire | Stable | Cache |
|-----------|----------|-------|------|---------|--------|-------|
| MergeSort | O(N log N) | O(N log N) | O(N log N) | O(N) | ✓ | Moyen |
| QuickSort | O(N log N) | O(N log N) | O(n²) | O(log N) | ✗ | ✓ Bon |
| HeapSort | O(N log N) | O(N log N) | O(N log N) | O(1) | ✗ | Moyen |

## Recommandations

- **Usage général** : QuickSort (très rapide en pratique)
- **Stabilité requise** : MergeSort
- **Garantie pire cas** : MergeSort ou HeapSort
- **Données externes** : MergeSort adapté

---

**[↑ Retour à la section 4](README.md)** | **[← Retour à l'index](../INDEX.md)**

# 4.3 Algorithmes Avancés (O(N log N))

Les algorithmes avancés utilisent la stratégie **diviser pour régner** pour obtenir une meilleure complexité.

## MergeSort (Tri par fusion)

### Concept

**Diviser** le tableau en deux, **trier** récursivement chaque moitié, puis **fusionner** les résultats.

```
[5, 2, 8, 1, 9]
        ↓
    [5, 2] [8, 1, 9]
        ↓
    [5] [2] [8] [1, 9]
        ↓
    [2, 5] [1, 8, 9]
        ↓
    [1, 2, 5, 8, 9]
```

### Implémentation

```java
public static void mergeSort(int[] arr, int left, int right) {
    if (left < right) {
        int mid = left + (right - left) / 2;
        mergeSort(arr, left, mid);      // Trier gauche
        mergeSort(arr, mid + 1, right); // Trier droite
        merge(arr, left, mid, right);   // Fusionner
    }
}

private static void merge(int[] arr, int left, int mid, int right) {
    int n1 = mid - left + 1;
    int n2 = right - mid;
    
    int[] leftArr = new int[n1];
    int[] rightArr = new int[n2];
    
    System.arraycopy(arr, left, leftArr, 0, n1);
    System.arraycopy(arr, mid + 1, rightArr, 0, n2);
    
    int i = 0, j = 0, k = left;
    while (i < n1 && j < n2) {
        if (leftArr[i] <= rightArr[j]) {
            arr[k++] = leftArr[i++];
        } else {
            arr[k++] = rightArr[j++];
        }
    }
    
    while (i < n1) arr[k++] = leftArr[i++];
    while (j < n2) arr[k++] = rightArr[j++];
}
```

### Complexité

- **Meilleur cas** : O(N log N)
- **Cas moyen** : O(N log N)
- **Pire cas** : O(N log N) - **Garanti !**
- **Mémoire** : O(N) - fusion nécessite espace temporaire
- **Stabilité** : ✓ Stable

### Avantages et inconvénients

**Avantages :**
- Complexité garantie O(N log N)
- Stable
- Bon pour données externes (disque)

**Inconvénients :**
- Mémoire supplémentaire O(N)
- Plus lent que QuickSort en moyenne sur données petites

## QuickSort (Tri rapide)

### Concept

Choisir un **pivot**, **partitionner** le tableau autour du pivot, puis **trier** récursivement les partitions.

```
[5, 2, 8, 1, 9] pivot = 5
        ↓
[2, 1] [5] [8, 9]
        ↓
[1, 2] [5] [8, 9]
        ↓
[1, 2, 5, 8, 9]
```

### Implémentation de base

```java
public static void quickSort(int[] arr, int low, int high) {
    if (low < high) {
        int pi = partition(arr, low, high);
        quickSort(arr, low, pi - 1);
        quickSort(arr, pi + 1, high);
    }
}

private static int partition(int[] arr, int low, int high) {
    int pivot = arr[high];
    int i = low - 1;
    
    for (int j = low; j < high; j++) {
        if (arr[j] < pivot) {
            i++;
            // Échanger
            int temp = arr[i];
            arr[i] = arr[j];
            arr[j] = temp;
        }
    }
    
    // Échanger pivot avec élément en i+1
    int temp = arr[i + 1];
    arr[i + 1] = arr[high];
    arr[high] = temp;
    
    return i + 1;
}
```

### Optimisation : QuickSort avec cutoff

Pour les petites partitions, **Insertion Sort** est plus rapide que QuickSort. L'optimisation consiste à utiliser un **cutoff** (seuil) : si la taille de la partition ≤ cutoff, utiliser Insertion Sort au lieu de continuer la récursion.

```java
private static final int CUTOFF = 3;  // Valeur typique entre 3 et 10

public static void quickSort(int[] arr, int low, int high) {
    if (low + CUTOFF <= high) {
        // Partition assez grande : utiliser QuickSort
        int pivot = median3(arr, low, high);
        
        // Partitionnement
        int i = low, j = high - 1;
        for (;;) {
            while (arr[++i] < pivot) { }
            while (arr[--j] > pivot) { }
            if (i < j) {
                swap(arr, i, j);
            } else {
                break;
            }
        }
        swap(arr, i, high - 1);  // Remettre pivot
        
        // Récursion
        quickSort(arr, low, i - 1);
        quickSort(arr, i + 1, high);
    } else {
        // Partition petite : utiliser Insertion Sort
        insertionSort(arr, low, high);
    }
}

private static void insertionSort(int[] arr, int low, int high) {
    for (int p = low + 1; p <= high; p++) {
        int tmp = arr[p];
        int j;
        for (j = p; j > low && tmp < arr[j - 1]; j--) {
            arr[j] = arr[j - 1];
        }
        arr[j] = tmp;
    }
}
```

**Nombre d'appels récursifs** : Pour un tableau de N éléments, le nombre d'appels dépend de la qualité du partitionnement :
- **Meilleur cas** (pivot médian) : ~2N appels (arbre binaire équilibré)
- **Pire cas** (pivot min/max) : N appels (arbre linéaire)
- **Avec cutoff = 3** : Moins d'appels car les partitions < 3 éléments arrêtent la récursion

### Sélection du pivot

La qualité du pivot affecte les performances :

- **Pivot aléatoire** : Bon en moyenne
- **Pivot médian-de-trois (median3)** : Choisir la médiane de (premier, milieu, dernier)

```java
private static int median3(int[] arr, int low, int high) {
    int mid = low + (high - low) / 2;
    
    // Trier low, mid, high
    if (arr[low] > arr[mid]) swap(arr, low, mid);
    if (arr[low] > arr[high]) swap(arr, low, high);
    if (arr[mid] > arr[high]) swap(arr, mid, high);
    
    // Placer pivot (médiane) à high-1
    swap(arr, mid, high - 1);
    return arr[high - 1];
}

private static void swap(int[] arr, int i, int j) {
    int temp = arr[i];
    arr[i] = arr[j];
    arr[j] = temp;
}
```

**Explication median3** :
1. Calcule la médiane de `arr[low]`, `arr[mid]`, `arr[high]`
2. Place le **plus petit** à `low`, le **plus grand** à `high`, la **médiane** à `mid`
3. Échange la médiane avec `arr[high-1]` pour l'utiliser comme pivot
4. Résultat : `arr[low] < pivot < arr[high]`, ce qui garantit que les sentinelles sont en place

### Complexité

- **Meilleur cas** : O(N log N) - pivot équilibre bien
- **Cas moyen** : O(N log N) - généralement très rapide
- **Pire cas** : O(n²) - pivot toujours min ou max
- **Mémoire** : O(log N) - pile de récursion
- **Stabilité** : ✗ Instable

### Avantages et inconvénients

**Avantages :**
- Très rapide en pratique (cache-friendly)
- Tri en place
- Espace mémoire minimal

**Inconvénients :**
- Complexité pire cas O(n²)
- Instable
- Sensible au choix du pivot

### Complexité

- **Meilleur et cas moyen** : O(N) - amorti
- **Pire cas** : O(N²)
- **Mémoire** : O(log N)

## Comparaison des tris avancés

| Algorithme | Meilleur | Moyen | Pire | Mémoire | Stable | Cache |
|-----------|----------|-------|------|---------|--------|-------|
| MergeSort | O(N log N) | O(N log N) | O(N log N) | O(N) | ✓ | Moyen |
| QuickSort | O(N log N) | O(N log N) | O(n²) | O(log N) | ✗ | ✓ Bon |
| HeapSort | O(N log N) | O(N log N) | O(N log N) | O(1) | ✗ | Moyen |

## Recommandations

- **Usage général** : QuickSort (très rapide en pratique)
- **Stabilité requise** : MergeSort
- **Garantie pire cas** : MergeSort ou HeapSort
- **Données externes** : MergeSort adapté

---

**[↑ Retour à la section 4](README.md)** | **[← Retour à l'index](../INDEX.md)**

# 7.2 Opérations et Complexité

## Insertion

Insérer le nouvel élément à la **fin** du monceau, puis utiliser **percolate up** pour le placer à la bonne position.

```
Avant insertion : [-, 1, 2, 3, 4, 5]

Insérer 0 :
1. Ajouter à la fin : [-, 1, 2, 3, 4, 5, 0]
2. Percolate up : comparer avec parent (5)
3. 0 < 5 → swap : [-, 1, 2, 3, 4, 0, 5]
4. Comparer 0 avec parent (2)
5. 0 < 2 → swap : [-, 1, 0, 3, 4, 2, 5]
6. Comparer 0 avec parent (1)
7. 0 < 1 → swap : [-, 0, 1, 3, 4, 2, 5] ✓

Résultat : [-, 0, 1, 3, 4, 2, 5]
```

### Implémentation

```java
public void insert(int value) {
    if (size >= heap.length - 1) {
        resize();
    }
    
    int i = ++size;
    heap[i] = value;
    
    // Percolate up
    while (i > 1 && heap[i] < heap[parent(i)]) {
        swap(i, parent(i));
        i = parent(i);
    }
}

private void resize() {
    int[] newHeap = new int[heap.length * 2];
    System.arraycopy(heap, 0, newHeap, 0, heap.length);
    heap = newHeap;
}
```

**Complexité :** O(log N) - hauteur du monceau

## Retrait du minimum (DeleteMin)

Supprimer la **racine** (minimum). Placer le **dernier élément** à la racine, puis utiliser **percolate down**.

```
Avant retrait :  [-, 0, 1, 3, 4, 2, 5]

DeleteMin :
1. Retirer racine (0), sauvegarder
2. Placer dernier élément (5) à la racine : [-, 5, 1, 3, 4, 2]
3. Percolate down : comparer 5 avec enfants (1 et 3)
4. Min enfants = 1, 5 > 1 → swap : [-, 1, 5, 3, 4, 2]
5. Comparer 5 avec enfants (4 et 2)
6. Min enfants = 2, 5 > 2 → swap : [-, 1, 2, 3, 4, 5]
7. 5 n'a plus d'enfants → stop ✓

Retour : 0
```

### Implémentation

```java
public int deleteMin() {
    if (size == 0) throw new IllegalStateException("Heap vide");
    
    int min = heap[1];
    heap[1] = heap[size];
    size--;
    
    // Percolate down
    percolateDown(1);
    
    return min;
}

private void percolateDown(int i) {
    int smallest = i;
    
    while (left(i) <= size) {
        int l = left(i);
        int r = right(i);
        
        // Trouver le plus petit enfant
        if (l <= size && heap[l] < heap[smallest]) {
            smallest = l;
        }
        if (r <= size && heap[r] < heap[smallest]) {
            smallest = r;
        }
        
        if (smallest != i) {
            swap(i, smallest);
            i = smallest;
        } else {
            break;
        }
    }
}
```

**Complexité :** O(log N) - hauteur du monceau

## Résumé des complexités

| Opération | Complexité |
|-----------|-----------|
| getMin() | O(1) |
| insert() | O(log N) |
| deleteMin() | O(log N) |
| Espace | O(N) |

---

**[↑ Retour à la section 7](README.md)** | **[← Retour à l'index](../INDEX.md)**

# 7.2 Opérations et Complexité

## Insertion

Insérer le nouvel élément à la **fin** du monceau, puis utiliser **percolate up** pour le placer à la bonne position.

```
Avant insertion : [-, 1, 2, 3, 4, 5]

Insérer 0 :
1. Ajouter à la fin : [-, 1, 2, 3, 4, 5, 0]
2. Percolate up : comparer avec parent (5)
3. 0 < 5 → swap : [-, 1, 2, 3, 4, 0, 5]
4. Comparer 0 avec parent (2)
5. 0 < 2 → swap : [-, 1, 0, 3, 4, 2, 5]
6. Comparer 0 avec parent (1)
7. 0 < 1 → swap : [-, 0, 1, 3, 4, 2, 5] ✓

Résultat : [-, 0, 1, 3, 4, 2, 5]
```

### Implémentation

```java
public void insert(int value) {
    if (size >= heap.length - 1) {
        resize();
    }
    
    int i = ++size;
    heap[i] = value;
    
    // Percolate up
    while (i > 1 && heap[i] < heap[parent(i)]) {
        swap(i, parent(i));
        i = parent(i);
    }
}

private void resize() {
    int[] newHeap = new int[heap.length * 2];
    System.arraycopy(heap, 0, newHeap, 0, heap.length);
    heap = newHeap;
}
```

**Complexité :** O(log N) - hauteur du monceau

## Retrait du minimum (DeleteMin)

Supprimer la **racine** (minimum). Placer le **dernier élément** à la racine, puis utiliser **percolate down**.

```
Avant retrait :  [-, 0, 1, 3, 4, 2, 5]

DeleteMin :
1. Retirer racine (0), sauvegarder
2. Placer dernier élément (5) à la racine : [-, 5, 1, 3, 4, 2]
3. Percolate down : comparer 5 avec enfants (1 et 3)
4. Min enfants = 1, 5 > 1 → swap : [-, 1, 5, 3, 4, 2]
5. Comparer 5 avec enfants (4 et 2)
6. Min enfants = 2, 5 > 2 → swap : [-, 1, 2, 3, 4, 5]
7. 5 n'a plus d'enfants → stop ✓

Retour : 0
```

### Implémentation

```java
public int deleteMin() {
    if (size == 0) throw new IllegalStateException("Heap vide");
    
    int min = heap[1];
    heap[1] = heap[size];
    size--;
    
    // Percolate down
    percolateDown(1);
    
    return min;
}

private void percolateDown(int i) {
    int smallest = i;
    
    while (left(i) <= size) {
        int l = left(i);
        int r = right(i);
        
        // Trouver le plus petit enfant
        if (l <= size && heap[l] < heap[smallest]) {
            smallest = l;
        }
        if (r <= size && heap[r] < heap[smallest]) {
            smallest = r;
        }
        
        if (smallest != i) {
            swap(i, smallest);
            i = smallest;
        } else {
            break;
        }
    }
}
```

**Complexité :** O(log N) - hauteur du monceau

## Trouver le k-ième plus petit élément

Pour un **min-heap**, trouver le k-ième plus petit élément (par exemple le 3e) peut être fait en O(k) en examinant seulement les k premiers niveaux.

### Algorithme pour trouver le 3e plus petit

```java
public int troisieme() {
    if (size < 3) {
        throw new IllegalStateException("Le monceau a moins de 3 éléments");
    }
    
    // Dans un min-heap, le 3e plus petit est soit:
    // - un des enfants de la racine (indices 2, 3)
    // - un des petits-enfants de la racine (indices 4, 5, 6, 7)
    
    int maxIndex = Math.min(7, size);  // Examiner jusqu'aux petits-enfants
    
    int[] smallest = new int[3];
    smallest[0] = heap[1];  // 1er plus petit (racine)
    
    // Trouver 2e et 3e plus petits parmi les enfants et petits-enfants
    smallest[1] = (heap[2] < heap[3]) ? heap[2] : heap[3];
    smallest[2] = (heap[2] >= heap[3]) ? heap[2] : heap[3];
    
    // Examiner les autres nœuds jusqu'à l'indice 7
    for (int i = 4; i <= maxIndex; i++) {
        if (heap[i] < smallest[1]) {
            smallest[2] = smallest[1];
            smallest[1] = heap[i];
        } else if (heap[i] < smallest[2]) {
            smallest[2] = heap[i];
        }
    }
    
    return smallest[2];
}
```

**Complexité :** O(1) car on examine au maximum 7 éléments (indices 1 à 7)

**Explication** :
- Dans un min-heap, le minimum est à la racine (indice 1)
- Le 2e minimum est soit `heap[2]` soit `heap[3]` (enfants directs)
- Le 3e minimum est dans les indices 2 à 7 (enfants et petits-enfants de la racine)
- Pas besoin de regarder plus loin car tout élément à l'indice > 7 a un parent qui est forcément plus grand que l'un des 7 premiers

## Résumé des complexités

| Opération | Complexité |
|-----------|-----------|
| getMin() | O(1) |
| insert() | O(log N) |
| deleteMin() | O(log N) |
| Espace | O(N) |

---

**[↑ Retour à la section 7](README.md)** | **[← Retour à l'index](../INDEX.md)**

# 7.3 Construction et Tri

## Construction du monceau (buildHeap)

Construire un monceau à partir d'un tableau non trié.

### Approche naïve

Insérer chaque élément un par un → O(N log N)

### Approche optimisée

Parcourir le tableau de bas en haut et appliquer **percolate down** sur chaque nœud → **O(N)**

```
Tableau : [5, 2, 8, 1, 9, 3]

Indices percolate down (du dernier parent au premier) :
- Index 2 (valeur 8) : percolate down
- Index 1 (valeur 2) : percolate down  
- Index 0 (valeur 5) : percolate down

Résultat : monceau en O(N)
```

### Implémentation

```java
public void buildHeap(int[] arr) {
    size = arr.length;
    heap = new int[size + 1];
    System.arraycopy(arr, 0, heap, 1, size);
    
    // Percolate down depuis le dernier parent jusqu'à la racine
    for (int i = size / 2; i >= 1; i--) {
        percolateDown(i);
    }
}
```

**Complexité :** O(N) - meilleur que O(N log N) pour insertion !

**Preuve (intuitive) :** 
- Au dernier niveau : N/2 nœuds, 0 déplacement
- Avant-dernier : N/4 nœuds, ≤1 déplacement 
- Avant-avant-dernier : N/8 nœuds, ≤2 déplacements
- ...
- Somme : N/2×0 + N/4×1 + N/8×2 + ... = O(N)

**Preuve rigoureuse** : Somme des hauteurs de tous les nœuds ≤ N

## Tri par monceau (Heapsort)

Utiliser un monceau pour trier en **O(N log N)** temps et **O(1)** espace supplémentaire (tri en place).

### Concept

1. Construire un **max-monceau** (racine = maximum)
2. Permuter racine (max) avec dernier élément
3. Réduire taille du monceau et percolate down
4. Répéter jusqu'à tri complet

```
Max-monceau : [9, 8, 5, 7, 2, 3, 1]

Étape 1 : Swap 9 avec 1 → [1, 8, 5, 7, 2, 3, 9] (9 trié)
         Percolate down 1 → [8, 7, 5, 1, 2, 3]
         
Étape 2 : Swap 8 avec 3 → [3, 7, 5, 1, 2, 8, 9]
         Percolate down 3 → [7, 3, 5, 1, 2]
         
... continuer jusqu'au tri
```

### Implémentation

```java
public static void heapSort(int[] arr) {
    int n = arr.length;
    
    // Construire max-heap
    for (int i = n / 2 - 1; i >= 0; i--) {
        heapify(arr, n, i);
    }
    
    // Extraire un par un et trier
    for (int i = n - 1; i > 0; i--) {
        // Swap racine (max) avec dernier
        int temp = arr[0];
        arr[0] = arr[i];
        arr[i] = temp;
        
        // Percolate down sur tas réduit
        heapify(arr, i, 0);
    }
}

private static void heapify(int[] arr, int n, int i) {
    int largest = i;
    int left = 2 * i + 1;
    int right = 2 * i + 2;
    
    if (left < n && arr[left] > arr[largest]) {
        largest = left;
    }
    if (right < n && arr[right] > arr[largest]) {
        largest = right;
    }
    
    if (largest != i) {
        int temp = arr[i];
        arr[i] = arr[largest];
        arr[largest] = temp;
        
        heapify(arr, n, largest);
    }
}
```

## Complexité du Heapsort

| Phase | Complexité |
|-------|-----------|
| buildHeap | O(N) |
| Extraire N éléments | O(N log N) |
| **Total** | **O(N log N)** |

**Espace** : O(1) - tri en place !

## Comparaison Heapsort vs QuickSort

| Aspect | Heapsort | QuickSort |
|--------|----------|-----------|
| Pire cas | O(N log N) | O(N²) |
| Cas moyen | O(N log N) | O(N log N) |
| Espace | O(1) | O(log N) |
| Cache | Moyen | ✓ Bon |
| Stabilité | ✗ Non | ✗ Non |

**Recommandation :**
- **QuickSort** : Plus rapide en pratique (cache friendly)
- **Heapsort** : Garantie O(N log N), espace minimal

---

**[↑ Retour à la section 7](README.md)** | **[← Retour à l'index](../INDEX.md)**

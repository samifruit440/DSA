# 8.2 Parcours et Connexité

## Résumé comparatif : BFS vs DFS

### Tableau synthétique

| Aspect | BFS | DFS |
|--------|-----|-----|
| **Structure utilisée** | File (FIFO) | Pile (LIFO) ou récursion |
| **Ordre de parcours** | Largeur (par niveau) | Profondeur (jusqu'au bout) |
| **Plus court chemin (sans poids)** | ✓ Oui | ✗ Non |
| **Détection de cycle** | ✓ Oui | ✓ Oui |
| **Composantes connexes** | ✓ Oui | ✓ Oui |
| **Ordre topologique** | ✗ Non | ✓ Oui (post-ordre inverse) |
| **Espace pile** | O(\|V\|) queue | O(\|V\|) récursion |
| **Timestamps (u.d, u.f)** | ✗ Distance uniquement | ✓ Oui |
| **Implémentation** | Itérative (boucle + file) | Récursive ou itérative + pile |

### Visualisation côte à côte

```
Graphe :       1
              / \
             2   3
            / \
           4   5

BFS depuis 1 :           DFS depuis 1 :
Étape 1 : Traiter 1      Étape 1 : Traiter 1
          Ajouter 2,3              Aller en 2
          File : [2, 3]            File : [3]

Étape 2 : Traiter 2      Étape 2 : Traiter 2
          Ajouter 4,5              Aller en 4
          File : [3, 4, 5]         Pile : [3, 5]

Étape 3 : Traiter 3      Étape 3 : Traiter 4
          Rien à ajouter           Retour à 2
          File : [4, 5]            Aller en 5
                                   Pile : [3]

Étape 4 : Traiter 4      Étape 4 : Traiter 5
          File : [5]               Retour à 2
                                   Retour à 1
                                   Aller en 3

Étape 5 : Traiter 5      Étape 5 : Traiter 3
          File : vide              Pile : vide

Ordre BFS : 1, 2, 3, 4, 5
Ordre DFS : 1, 2, 4, 5, 3
```

## Parcours en largeur (BFS - Breadth-First Search)

Parcourir le graphe par **niveaux**, en utilisant une **file (queue)**.

### Concept

1. Partir du sommet initial
2. Ajouter tous les voisins à la file
3. Traiter le prochain sommet de la file
4. Répéter jusqu'à épuisement

```
Graphe :    1 -- 2
            |    |
            3 -- 4

BFS depuis 1 :
Étape 1 : Visiter 1, ajouter [2, 3] à file
Étape 2 : Visiter 2, ajouter [4] (3 déjà vu)
Étape 3 : Visiter 3, queue = [4]
Étape 4 : Visiter 4, queue vide

Ordre : 1, 2, 3, 4
```

### Implémentation

```java
public void bfs(int start) {
    boolean[] visited = new boolean[numVertices];
    Queue<Integer> queue = new LinkedList<>();
    
    visited[start] = true;
    queue.offer(start);
    
    while (!queue.isEmpty()) {
        int u = queue.poll();
        System.out.println(u);
        
        for (int v : getNeighbors(u)) {
            if (!visited[v]) {
                visited[v] = true;
                queue.offer(v);
            }
        }
    }
}
```

**Complexité :**
- **Temps :** O(|V| + |E|) - chaque sommet et arête visité une fois
- **Espace :** O(|V|) - file et tableau visited

**Propriété :** Trouve le **plus court chemin** (sans poids)

### BFS par niveau avec distances

Une variante utile enregistre la **distance** de chaque sommet à la source.

```java
public class BFSWithLevels {
    private int[] distance;
    private int[] parent;
    
    public void bfs(Graph G, int start) {
        int n = G.V();
        distance = new int[n];
        parent = new int[n];
        
        for (int i = 0; i < n; i++) {
            distance[i] = -1;  // -1 = non visité
        }
        
        Queue<Integer> queue = new LinkedList<>();
        distance[start] = 0;
        parent[start] = -1;
        queue.offer(start);
        
        while (!queue.isEmpty()) {
            int u = queue.poll();
            System.out.println("Sommet " + u + ", distance = " + distance[u]);
            
            for (int v : G.adj(u)) {
                if (distance[v] == -1) {  // Non visité
                    distance[v] = distance[u] + 1;
                    parent[v] = u;
                    queue.offer(v);
                }
            }
        }
    }
    
    public void printDistances() {
        System.out.println("Sommet | Distance");
        for (int i = 0; i < distance.length; i++) {
            if (distance[i] != -1) {
                System.out.println(i + " | " + distance[i]);
            }
        }
    }
}
```

**Exemple avec parcours par niveau :**
```
Graphe :       1
              / \
             2   3
            / \
           4   5

BFS depuis 1 :
Niveau 0 : [1]
Niveau 1 : [2, 3]
Niveau 2 : [4, 5]

Parcours :
Étape 1 : Traiter 1, distance[1]=0, ajouter 2,3
Étape 2 : Traiter 2, distance[2]=1, ajouter 4,5
Étape 3 : Traiter 3, distance[3]=1
Étape 4 : Traiter 4, distance[4]=2
Étape 5 : Traiter 5, distance[5]=2
```

**Points clés :**
- Les sommets du même niveau ont la même distance
- Le BFS explore chaque niveau entièrement avant de passer au suivant
- Très utile pour les problèmes de **plus court chemin sans poids**

## Parcours en profondeur (DFS - Depth-First Search)

Parcourir le graphe en **profondeur**, en utilisant **récursion (pile implicite)**.

### Concept

1. Partir du sommet initial
2. Descendre aussi loin que possible
3. Rebrousser chemin quand tous les voisins sont visités
4. Continuer avec un autre sommet non visité

```
Graphe :    1 -- 2
            |    |
            3 -- 4

DFS depuis 1 :
Étape 1 : Visiter 1, choisir voisin 2
Étape 2 : Visiter 2, choisir voisin 4
Étape 3 : Visiter 4, pas de nouveaux voisins → retour
Retour à 2 → retour à 1
Étape 4 : Depuis 1, visiter voisin 3
Étape 5 : Visiter 3, pas de nouveaux voisins → retour

Ordre : 1, 2, 4, 3
```

### Implémentation

```java
public void dfs(int start) {
    boolean[] visited = new boolean[numVertices];
    dfsHelper(start, visited);
}

private void dfsHelper(int u, boolean[] visited) {
    visited[u] = true;
    System.out.println(u);
    
    for (int v : getNeighbors(u)) {
        if (!visited[v]) {
            dfsHelper(v, visited);
        }
    }
}
```

### DFS avec temps de découverte (u.d) et fermeture (u.f)

Pour analyser la structure du graphe, on peut ajouter des **timestamps** qui enregistrent :
- **u.d (découverte)** : moment où on visite le sommet u pour la première fois
- **u.f (fermeture)** : moment où on a fini de traiter tous les voisins de u

```java
public class DFSWithTimestamps {
    private int[] discoveryTime;
    private int[] finishTime;
    private boolean[] visited;
    private int time = 0;
    private int numVertices;
    
    public DFSWithTimestamps(int numVertices) {
        this.numVertices = numVertices;
        discoveryTime = new int[numVertices];
        finishTime = new int[numVertices];
        visited = new boolean[numVertices];
    }
    
    public void dfs(Graph G) {
        for (int i = 0; i < numVertices; i++) {
            if (!visited[i]) {
                dfsHelper(G, i);
            }
        }
    }
    
    private void dfsHelper(Graph G, int u) {
        visited[u] = true;
        discoveryTime[u] = ++time;  // Timestamp de découverte
        System.out.println("u.d(" + u + ") = " + discoveryTime[u]);
        
        // Traiter tous les voisins
        for (int v : G.adj(u)) {
            if (!visited[v]) {
                dfsHelper(G, v);
            }
        }
        
        finishTime[u] = ++time;  // Timestamp de fermeture
        System.out.println("u.f(" + u + ") = " + finishTime[u]);
    }
    
    public void printTimestamps() {
        System.out.println("Sommet | u.d | u.f");
        for (int i = 0; i < numVertices; i++) {
            System.out.println(i + " | " + discoveryTime[i] + " | " + finishTime[i]);
        }
    }
}
```

**Exemple avec graphe simple :**
```
Graphe :    1 → 2
            ↓   ↓
            3   4

DFS depuis 1 :
Visiter 1 : u.d(1) = 1
  Visiter 2 : u.d(2) = 2
    Visiter 4 : u.d(4) = 3
    u.f(4) = 4
  u.f(2) = 5
  Visiter 3 : u.d(3) = 6
  u.f(3) = 7
u.f(1) = 8

Résultat :
Sommet | u.d | u.f
1      | 1   | 8
2      | 2   | 5
3      | 6   | 7
4      | 3   | 4
```

**Propriétés importantes :**
- Les intervalles [u.d, u.f] et [v.d, v.f] sont soit **disjoints**, soit **imbriqués** (jamais partiellement chevauchants)
- Si [v.d, v.f] ⊆ [u.d, u.f], alors v est un descendant de u dans l'arbre DFS
- Les timestamps permettent de **classer les arêtes** du graphe

### DFS Post-ordre et Post-ordre inverse

Pour l'ordre topologique, on utilise le **post-ordre** : traiter les sommets dans l'ordre de leur fermeture.

```java
public List<Integer> dfsPostOrder(Graph G) {
    Stack<Integer> stack = new Stack<>();
    boolean[] visited = new boolean[G.V()];
    
    for (int i = 0; i < G.V(); i++) {
        if (!visited[i]) {
            dfsPostOrderHelper(G, i, visited, stack);
        }
    }
    
    List<Integer> result = new ArrayList<>();
    while (!stack.isEmpty()) {
        result.add(stack.pop());  // Post-ordre inverse
    }
    return result;
}

private void dfsPostOrderHelper(Graph G, int u, boolean[] visited, Stack<Integer> stack) {
    visited[u] = true;
    
    for (int v : G.adj(u)) {
        if (!visited[v]) {
            dfsPostOrderHelper(G, v, visited, stack);
        }
    }
    
    stack.push(u);  // Ajouter après avoir traité tous les voisins (post-ordre)
}
```

**Exemple :**
```
Post-ordre : [5, 4, 1, 2, 3, 0]  (ordre de fermeture)
Post-ordre inverse : [0, 3, 2, 1, 4, 5]  (utilisé pour ordre topologique)
```

**Complexité :**
- **Temps :** O(|V| + |E|)
- **Espace :** O(|V|) - pile de récursion

## Composantes connexes (Graphes non orientés)

Identifier les **composantes connexes** (sous-graphes isolés).

```java
public int countComponents() {
    boolean[] visited = new boolean[numVertices];
    int count = 0;
    
    for (int i = 0; i < numVertices; i++) {
        if (!visited[i]) {
            dfs(i, visited);
            count++;
        }
    }
    
    return count;
}

private void dfs(int u, boolean[] visited) {
    visited[u] = true;
    for (int v : getNeighbors(u)) {
        if (!visited[v]) {
            dfs(v, visited);
        }
    }
}
```

## Composantes fortement connexes (Graphes orientés)

Identifier les **composantes fortement connexes** : sous-graphes où tout sommet peut atteindre tout autre.

**Algorithme de Kosaraju-Sharir :**

1. DFS sur G et sauvegarder l'ordre de fin (post-ordre)
2. Créer le graphe transposé GT
3. DFS sur GT dans l'ordre décroissant de fin de 1

```java
public int countSCC() {
    // Étape 1 : DFS sur G, remplir pile de fin
    Stack<Integer> stack = new Stack<>();
    boolean[] visited = new boolean[numVertices];
    
    for (int i = 0; i < numVertices; i++) {
        if (!visited[i]) {
            dfsFill(i, visited, stack);
        }
    }
    
    // Étape 2 : DFS sur GT en ordre inverse
    GraphList gt = transpose();
    visited = new boolean[numVertices];
    int count = 0;
    
    while (!stack.isEmpty()) {
        int u = stack.pop();
        if (!visited[u]) {
            gt.dfs(u, visited);
            count++;
        }
    }
    
    return count;
}

private void dfsFill(int u, boolean[] visited, Stack<Integer> stack) {
    visited[u] = true;
    for (int v : getNeighbors(u)) {
        if (!visited[v]) {
            dfsFill(v, visited, stack);
        }
    }
    stack.push(u);
}
```

## Design Pattern : Classe Paths

### Implémentation

```java
public class Paths {
    private boolean[] dfsMarked, bfsMarked;
    private int[] dfsParent, bfsParent;
    private int source;
    
    public Paths(Graph G, int s) {
        this.source = s;
        
        // Initialiser et lancer BFS
        bfsMarked = new boolean[G.V()];
        bfsParent = new int[G.V()];
        bfs(G, s);
        
        // Initialiser et lancer DFS
        dfsMarked = new boolean[G.V()];
        dfsParent = new int[G.V()];
        dfs(G, s);
    }
    
    private void bfs(Graph G, int s) {
        Queue<Integer> q = new LinkedList<>();
        q.add(s);
        bfsMarked[s] = true;
        
        while (!q.isEmpty()) {
            int v = q.poll();
            for (int w : G.adj(v)) {
                if (!bfsMarked[w]) {
                    bfsMarked[w] = true;
                    bfsParent[w] = v;
                    q.add(w);
                }
            }
        }
    }
    
    private void dfs(Graph G, int s) {
        dfsMarked[s] = true;
        for (int w : G.adj(s)) {
            if (!dfsMarked[w]) {
                dfsParent[w] = s;
                dfs(G, w);
            }
        }
    }
    
    // Récupérer le chemin BFS
    public Stack<Integer> bfsPathTo(int v) {
        if (!bfsMarked[v]) return null;
        
        Stack<Integer> path = new Stack<>();
        for (int x = v; x != source; x = bfsParent[x]) {
            path.push(x);
        }
        path.push(source);
        return path;
    }
    
    // Récupérer le chemin DFS
    public Stack<Integer> dfsPathTo(int v) {
        if (!dfsMarked[v]) return null;
        
        Stack<Integer> path = new Stack<>();
        for (int x = v; x != source; x = dfsParent[x]) {
            path.push(x);
        }
        path.push(source);
        return path;
    }
    
    // Vérifier si un sommet est accessible
    public boolean hasPathTo(int v) {
        return bfsMarked[v];  // ou dfsMarked[v]
    }
}
```

**Utilisation :**

```java
Graph G = new Graph(7);
// Ajouter des arêtes...

Paths paths = new Paths(G, 0);  // Source = 0

if (paths.hasPathTo(6)) {
    Stack<Integer> path = paths.bfsPathTo(6);
    System.out.println("Chemin BFS de 0 à 6 : " + path);
}
```

**Avantages de cette approche :**
- Séparation des responsabilités (parcours vs structure)
- Réutilisable et testable
- Permet de reconstruire les chemins facilement
- Stocke les résultats des deux parcours pour comparaison

## Comparaison BFS vs DFS

| Aspect | BFS | DFS |
|--------|-----|-----|
| Structure | File | Pile (récursion) |
| Ordre | Largeur | Profondeur |
| Chemin court | ✓ Oui | ✗ Non |
| Espace | O(\|V\|) | O(\|V\|) |
| Récursion | ✗ Non | ✓ Oui |

---

**[↑ Retour à la section 8](README.md)** | **[← Retour à l'index](../INDEX.md)**

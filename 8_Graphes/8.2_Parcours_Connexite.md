# 8.2 Parcours et Connexité

## Parcours en largeur (BFS - Breadth-First Search)

Parcourir le graphe par **niveaux**, en utilisant une **file (queue)**.

### Concept

1. Partir du sommet initial
2. Ajouter tous les voisins à la file
3. Traiter le prochain sommet de la file
4. Répéter jusqu'à épuisement

```
Graphe :    1 -- 2
            |    |
            3 -- 4

BFS depuis 1 :
Étape 1 : Visiter 1, ajouter [2, 3] à file
Étape 2 : Visiter 2, ajouter [4] (3 déjà vu)
Étape 3 : Visiter 3, queue = [4]
Étape 4 : Visiter 4, queue vide

Ordre : 1, 2, 3, 4
```

### Implémentation

```java
public void bfs(int start) {
    boolean[] visited = new boolean[numVertices];
    Queue<Integer> queue = new LinkedList<>();
    
    visited[start] = true;
    queue.offer(start);
    
    while (!queue.isEmpty()) {
        int u = queue.poll();
        System.out.println(u);
        
        for (int v : getNeighbors(u)) {
            if (!visited[v]) {
                visited[v] = true;
                queue.offer(v);
            }
        }
    }
}
```

**Complexité :**
- **Temps :** O(|V| + |E|) - chaque sommet et arête visité une fois
- **Espace :** O(|V|) - file et tableau visited

**Propriété :** Trouve le **plus court chemin** (sans poids)

## Parcours en profondeur (DFS - Depth-First Search)

Parcourir le graphe en **profondeur**, en utilisant **récursion (pile implicite)**.

### Concept

1. Partir du sommet initial
2. Descendre aussi loin que possible
3. Rebrousser chemin quand tous les voisins sont visités
4. Continuer avec un autre sommet non visité

```
Graphe :    1 -- 2
            |    |
            3 -- 4

DFS depuis 1 :
Étape 1 : Visiter 1, choisir voisin 2
Étape 2 : Visiter 2, choisir voisin 4
Étape 3 : Visiter 4, pas de nouveaux voisins → retour
Retour à 2 → retour à 1
Étape 4 : Depuis 1, visiter voisin 3
Étape 5 : Visiter 3, pas de nouveaux voisins → retour

Ordre : 1, 2, 4, 3
```

### Implémentation

```java
public void dfs(int start) {
    boolean[] visited = new boolean[numVertices];
    dfsHelper(start, visited);
}

private void dfsHelper(int u, boolean[] visited) {
    visited[u] = true;
    System.out.println(u);
    
    for (int v : getNeighbors(u)) {
        if (!visited[v]) {
            dfsHelper(v, visited);
        }
    }
}
```

**Complexité :**
- **Temps :** O(|V| + |E|)
- **Espace :** O(|V|) - pile de récursion

## Composantes connexes (Graphes non orientés)

Identifier les **composantes connexes** (sous-graphes isolés).

```java
public int countComponents() {
    boolean[] visited = new boolean[numVertices];
    int count = 0;
    
    for (int i = 0; i < numVertices; i++) {
        if (!visited[i]) {
            dfs(i, visited);
            count++;
        }
    }
    
    return count;
}

private void dfs(int u, boolean[] visited) {
    visited[u] = true;
    for (int v : getNeighbors(u)) {
        if (!visited[v]) {
            dfs(v, visited);
        }
    }
}
```

## Composantes fortement connexes (Graphes orientés)

Identifier les **composantes fortement connexes** : sous-graphes où tout sommet peut atteindre tout autre.

**Algorithme de Kosaraju-Sharir :**

1. DFS sur G et sauvegarder l'ordre de fin (post-ordre)
2. Créer le graphe transposé GT
3. DFS sur GT dans l'ordre décroissant de fin de 1

```java
public int countSCC() {
    // Étape 1 : DFS sur G, remplir pile de fin
    Stack<Integer> stack = new Stack<>();
    boolean[] visited = new boolean[numVertices];
    
    for (int i = 0; i < numVertices; i++) {
        if (!visited[i]) {
            dfsFill(i, visited, stack);
        }
    }
    
    // Étape 2 : DFS sur GT en ordre inverse
    GraphList gt = transpose();
    visited = new boolean[numVertices];
    int count = 0;
    
    while (!stack.isEmpty()) {
        int u = stack.pop();
        if (!visited[u]) {
            gt.dfs(u, visited);
            count++;
        }
    }
    
    return count;
}

private void dfsFill(int u, boolean[] visited, Stack<Integer> stack) {
    visited[u] = true;
    for (int v : getNeighbors(u)) {
        if (!visited[v]) {
            dfsFill(v, visited, stack);
        }
    }
    stack.push(u);
}
```

## Design Pattern : Classe Paths

### Implémentation

```java
public class Paths {
    private boolean[] dfsMarked, bfsMarked;
    private int[] dfsParent, bfsParent;
    private int source;
    
    public Paths(Graph G, int s) {
        this.source = s;
        
        // Initialiser et lancer BFS
        bfsMarked = new boolean[G.V()];
        bfsParent = new int[G.V()];
        bfs(G, s);
        
        // Initialiser et lancer DFS
        dfsMarked = new boolean[G.V()];
        dfsParent = new int[G.V()];
        dfs(G, s);
    }
    
    private void bfs(Graph G, int s) {
        Queue<Integer> q = new LinkedList<>();
        q.add(s);
        bfsMarked[s] = true;
        
        while (!q.isEmpty()) {
            int v = q.poll();
            for (int w : G.adj(v)) {
                if (!bfsMarked[w]) {
                    bfsMarked[w] = true;
                    bfsParent[w] = v;
                    q.add(w);
                }
            }
        }
    }
    
    private void dfs(Graph G, int s) {
        dfsMarked[s] = true;
        for (int w : G.adj(s)) {
            if (!dfsMarked[w]) {
                dfsParent[w] = s;
                dfs(G, w);
            }
        }
    }
    
    // Récupérer le chemin BFS
    public Stack<Integer> bfsPathTo(int v) {
        if (!bfsMarked[v]) return null;
        
        Stack<Integer> path = new Stack<>();
        for (int x = v; x != source; x = bfsParent[x]) {
            path.push(x);
        }
        path.push(source);
        return path;
    }
    
    // Récupérer le chemin DFS
    public Stack<Integer> dfsPathTo(int v) {
        if (!dfsMarked[v]) return null;
        
        Stack<Integer> path = new Stack<>();
        for (int x = v; x != source; x = dfsParent[x]) {
            path.push(x);
        }
        path.push(source);
        return path;
    }
    
    // Vérifier si un sommet est accessible
    public boolean hasPathTo(int v) {
        return bfsMarked[v];  // ou dfsMarked[v]
    }
}
```

**Utilisation :**

```java
Graph G = new Graph(7);
// Ajouter des arêtes...

Paths paths = new Paths(G, 0);  // Source = 0

if (paths.hasPathTo(6)) {
    Stack<Integer> path = paths.bfsPathTo(6);
    System.out.println("Chemin BFS de 0 à 6 : " + path);
}
```

**Avantages de cette approche :**
- Séparation des responsabilités (parcours vs structure)
- Réutilisable et testable
- Permet de reconstruire les chemins facilement
- Stocke les résultats des deux parcours pour comparaison

## Comparaison BFS vs DFS

| Aspect | BFS | DFS |
|--------|-----|-----|
| Structure | File | Pile (récursion) |
| Ordre | Largeur | Profondeur |
| Chemin court | ✓ Oui | ✗ Non |
| Espace | O(\|V\|) | O(\|V\|) |
| Récursion | ✗ Non | ✓ Oui |

---

**[↑ Retour à la section 8](README.md)** | **[← Retour à l'index](../INDEX.md)**

# 8.4 Arbres Sous-tendant Minimum (MST)

## Problématique

Donné un **graphe non orienté valuée** (avec poids), trouver un **arbre couvrant** (spanning tree) avec le **coût total minimum**.

```
Graphe complet :           Arbre couvrant minimal (MST) :
    1 ---(5)--- 2              1           2
    |           |              |           |
   (1)         (3)            (1)         (3)
    |           |              |           |
    3 ---(2)--- 4              3 ---(2)--- 4

Arêtes disponibles :       Arêtes sélectionnées :
(1,2) : 5                  (1,3) : 1
(1,3) : 1                  (3,4) : 2
(2,4) : 3                  (4,2) : 3
(3,4) : 2                  
                           Coût total = 1 + 2 + 3 = 6
```

**Propriété :** Un arbre couvrant minimal connecte tous les sommets avec |V| - 1 arêtes et sans cycles.

## Algorithme de Prim

Algorithme **glouton (greedy)** : construire l'arbre en ajoutant progressivement les **arêtes les moins chères** qui relient un sommet dans l'arbre à un sommet en dehors.

### Concept

1. Commencer avec un sommet arbitraire
2. Répéter |V| - 1 fois :
   - Choisir l'arête la moins chère reliant un sommet dans l'arbre à un sommet dehors
   - Ajouter cette arête et le nouveau sommet

```
Graphe :    1 ---(5)--- 2
            |           |
           (1)         (3)
            |           |
            3 ---(2)--- 4

Prim depuis 1 :
Étape 1 : Arbre = {1}, voisins accessibles = {(1,3):1, (1,2):5}
          → Choisir (1,3) car poids 1 est min
          
Étape 2 : Arbre = {1,3}, voisins accessibles = {(1,2):5, (3,4):2}
          → Choisir (3,4) car poids 2 est min
          
Étape 3 : Arbre = {1,3,4}, voisins accessibles = {(1,2):5, (4,2):3}
          → Choisir (4,2) car poids 3 est min
          
Étape 4 : Arbre = {1,3,4,2}. Tous sommets visités.

MST = {(1,3), (3,4), (4,2)}, coût total = 1+2+3 = 6
```

### Implémentation

```java
public int primMST() {
    boolean[] inMST = new boolean[numVertices];
    int[] key = new int[numVertices];
    int totalCost = 0;
    
    // Initialiser
    for (int i = 0; i < numVertices; i++) {
        key[i] = Integer.MAX_VALUE;
    }
    key[0] = 0;
    
    PriorityQueue<Pair> pq = new PriorityQueue<>();
    pq.offer(new Pair(0, 0));  // (poids, sommet)
    
    while (!pq.isEmpty()) {
        Pair p = pq.poll();
        int u = p.vertex;
        
        if (inMST[u]) continue;
        inMST[u] = true;
        totalCost += p.weight;
        
        // Mettre à jour clés des voisins
        for (int v : getNeighbors(u)) {
            int weight = getWeight(u, v);
            if (!inMST[v] && weight < key[v]) {
                key[v] = weight;
                pq.offer(new Pair(weight, v));
            }
        }
    }
    
    return totalCost;
}
```

**Complexité :** O((|V| + |E|) log |V|) avec min-heap (PriorityQueue)

**Alternative** : Avec un tableau simple (recherche min linéaire) : O(|V|²) - bon pour graphes denses

## Algorithme de Kruskal

Algorithme **glouton (greedy)** : trier les arêtes par poids croissant et les ajouter une par une si elles ne créent pas de cycle (en utilisant **Union-Find**).

### Concept

1. Trier les arêtes par poids croissant
2. Répéter pour chaque arête :
   - Si les deux sommets ne sont pas dans le même ensemble, ajouter l'arête
   - Fusionner les deux ensembles

```
Graphe (même que Prim) :
Arêtes triées par poids croissant :
(1,3) poids 1 → (3,4) poids 2 → (4,2) poids 3 → (1,2) poids 5

Étape 1 : Ajouter (1,3) poids 1, Union(1,3)
Étape 2 : Ajouter (3,4) poids 2, Union(3,4)
Étape 3 : Ajouter (4,2) poids 3, Union(4,2)
Étape 4 : (1,2) poids 5 créerait un cycle (1 et 2 déjà connectés), ignorer

MST = {(1,3), (3,4), (4,2)}, coût total = 1+2+3 = 6
```

### Implémentation

```java
public int kruskalMST(List<Edge> edges) {
    // Trier les arêtes par poids
    Collections.sort(edges, (e1, e2) -> Integer.compare(e1.weight, e2.weight));
    
    UnionFind uf = new UnionFind(numVertices);
    int totalCost = 0;
    int edgesAdded = 0;
    
    for (Edge e : edges) {
        // Si les sommets ne sont pas connectés
        if (uf.find(e.u) != uf.find(e.v)) {
            uf.union(e.u, e.v);
            totalCost += e.weight;
            edgesAdded++;
            
            if (edgesAdded == numVertices - 1) {
                break;  // MST complet
            }
        }
    }
    
    return totalCost;
}
```

**Complexité :** O(|E| log |E|) pour tri + O(|E| α(|V|)) pour Union-Find ≈ O(|E| log |E|)

## Comparaison Prim vs Kruskal

| Aspect | Prim | Kruskal |
|--------|------|---------|
| Stratégie | Arête min vers dehors | Arête globale min |
| Structure | File de priorité | Union-Find |
| Complexité | O((V+E) log V) | O(E log E) |
| Dense | ✓ Mieux | Moins bon |
| Peu dense | Moins bon | ✓ Mieux |
| Implémentation | Modérée | Modérée |

**Recommandation :**
- **Graphes denses** : Prim
- **Graphes peu denses** : Kruskal

---

**[↑ Retour à la section 8](README.md)** | **[← Retour à l'index](../INDEX.md)**

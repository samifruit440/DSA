# 8.3 Algorithmes de Chemin et d'Ordre

## Ordre topologique (Topological Sort)

Ordonner les sommets d'un **graphe orienté acyclique (DAG)** tel que pour chaque arête (u→v), u précède v.

```
Exemple DAG (dépendances) :
    Chaussettes
         |
         v
    Pantalon --- Ceinture
         |          |
         v          v
      Bottes      Veste
         |          |
         v          v
      ----Chaussures----

Ordre topologique valide : Chaussettes, Pantalon, Ceinture, Bottes, Veste, Chaussures
```

### Algorithme par File (basé sur degré entrant)

```java
public List<Integer> topologicalSort() {
    // Calculer le degré entrant de chaque sommet
    int[] inDegree = new int[numVertices];
    for (int u = 0; u < numVertices; u++) {
        for (int v : getNeighbors(u)) {
            inDegree[v]++;
        }
    }
    
    // Ajouter tous les sommets avec degré entrant 0
    Queue<Integer> queue = new LinkedList<>();
    for (int i = 0; i < numVertices; i++) {
        if (inDegree[i] == 0) {
            queue.offer(i);
        }
    }
    
    List<Integer> result = new ArrayList<>();
    while (!queue.isEmpty()) {
        int u = queue.poll();
        result.add(u);
        
        // Réduire le degré entrant des voisins
        for (int v : getNeighbors(u)) {
            inDegree[v]--;
            if (inDegree[v] == 0) {
                queue.offer(v);
            }
        }
    }
    
    return result;
}
```

**Complexité :** O(|V| + |E|)

### Algorithme par DFS (post-ordre inverse)

```java
public List<Integer> topologicalSortDFS() {
    Stack<Integer> stack = new Stack<>();
    boolean[] visited = new boolean[numVertices];
    
    for (int i = 0; i < numVertices; i++) {
        if (!visited[i]) {
            dfsFill(i, visited, stack);
        }
    }
    
    List<Integer> result = new ArrayList<>();
    while (!stack.isEmpty()) {
        result.add(stack.pop());
    }
    
    return result;
}
```

**Complexité :** O(|V| + |E|)

## Dijkstra : Plus court chemin avec poids

Trouver le chemin le plus court d'une **source** vers tous les sommets, avec poids **non-négatifs**.

### Concept

1. Initialiser distances : source=0, autres=∞
2. Répéter |V| fois :
   - Choisir sommet non visité avec distance min
   - Mettre à jour distances des voisins
   - Marquer comme visité

```
Graphe valuée :
    1 ---(2)--- 2
    |           |
   (7)         (3)
    |           |
    3 ---(4)--- 4

Dijkstra depuis 1 :
Dist[1]=0, Dist[2,3,4]=∞

Étape 1 : Visiter 1, mettre à jour :
  Dist[2]=2, Dist[3]=7

Étape 2 : Visiter 2, mettre à jour :
  Dist[4]=5 (via 2→4)

Étape 3 : Visiter 4, Dist[3]=min(7, 5+4)=7

Résultat : Dist[1:4] = [0, 2, 7, 5]
```

### Implémentation

```java
// Classe auxiliaire pour la file de priorité
class Pair implements Comparable<Pair> {
    int distance;
    int vertex;
    
    Pair(int distance, int vertex) {
        this.distance = distance;
        this.vertex = vertex;
    }
    
    @Override
    public int compareTo(Pair other) {
        return Integer.compare(this.distance, other.distance);
    }
}

public int[] dijkstra(int src) {
    int[] dist = new int[numVertices];
    boolean[] visited = new boolean[numVertices];
    
    // Initialiser
    for (int i = 0; i < numVertices; i++) {
        dist[i] = Integer.MAX_VALUE;
    }
    dist[src] = 0;
    
    // File de priorité : (distance, sommet)
    PriorityQueue<Pair> pq = new PriorityQueue<>();
    pq.offer(new Pair(0, src));
    
    while (!pq.isEmpty()) {
        Pair p = pq.poll();
        int u = p.vertex;
        
        if (visited[u]) continue;
        visited[u] = true;
        
        // Mettre à jour voisins (relaxation)
        for (int v : getNeighbors(u)) {
            int weight = getWeight(u, v);
            if (!visited[v] && dist[u] + weight < dist[v]) {
                dist[v] = dist[u] + weight;
                pq.offer(new Pair(dist[v], v));
            }
        }
    }
    
    return dist;
}
```

**Complexité :**
- Avec file simple (recherche min) : O(|V|²)
- Avec min-heap (PriorityQueue) : O((|V| + |E|) log |V|)

**Limitation :** Poids **non-négatifs** uniquement (pour poids négatifs, utiliser Bellman-Ford)

---

**[↑ Retour à la section 8](README.md)** | **[← Retour à l'index](../INDEX.md)**

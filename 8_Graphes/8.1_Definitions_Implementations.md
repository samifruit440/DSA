# 8.1 Définitions et Implémentations

## Définition formelle d'un graphe

Un **graphe** G = (V, E) est composé de :
- **V** : Ensemble de **sommets (vertices)** ou **nœuds**
- **E** : Ensemble d'**arêtes (edges)** ou **arcs** reliant les sommets

```
Sommets : {1, 2, 3, 4}
Arêtes : {(1,2), (1,3), (2,3), (3,4), ...}
```

## Terminologie

### Types de graphes

**Graphe non orienté (Undirected)** :
- Les arêtes n'ont pas de direction
- (1,2) = (2,1)

**Graphe orienté (Directed)** :
- Les arêtes ont une direction
- (1→2) ≠ (2→1)

**Graphe valuée (Weighted)** :
- Les arêtes ont des poids (distances, coûts)

### Concepts importants

- **Chemin (Path)** : Séquence de sommets où chaque paire consécutive est connectée
- **Cycle** : Chemin qui commence et finit au même sommet
- **Acyclique** : Pas de cycles
- **Connexe (Connected Graph)** : Il existe un chemin entre n'importe quelle paire de sommets
- **Fortement connexe (Strongly Connected, graphe orienté)** : Chemin de chaque sommet à chaque autre sommet

### Densité

- **Graphe dense** : |E| ≈ |V|² (beaucoup d'arêtes)
- **Graphe peu dense (Sparse)** : |E| ≈ |V| (peu d'arêtes)

## Implémentations

### Matrice d'adjacence

Matrice M où M[i][j] = poids (ou 1/0) s'il existe une arête (i,j).

```
Graphe non orienté :    1 -- 2        Graphe orienté :    1 → 2
                        |\  /                               ↙ ↓
                        | \/                              3 → 4
                        | /\
                        |/  \
                        3 -- 4

Matrice NON ORIENTÉE (SYMÉTRIQUE) :    Matrice ORIENTÉE (NON symétrique) :
     1 2 3 4                                1 2 3 4
  1 [0 1 1 1]                            1 [0 1 0 0]
  2 [1 0 1 0]                            2 [0 0 1 1]
  3 [1 1 0 1]                            3 [0 0 0 1]
  4 [1 0 1 0]                            4 [0 0 0 0]
  
M[i][j] = M[j][i] ✓                     M[i][j] ≠ M[j][i] généralement ✗
```

**Une matrice d'adjacence orientée n'est PAS toujours symétrique!**
- **Graphe non orienté** → Matrice **symétrique** (M[i][j] = M[j][i]), chaque lien est à double sens !
- **Graphe orienté** → Matrice **généralement non symétrique**

### Implémentation

```java
public class GraphMatrix {
    private int[][] adj;
    private int numVertices;
    private boolean directed;
    
    public GraphMatrix(int n, boolean directed) {
        numVertices = n;
        this.directed = directed;
        adj = new int[n][n];
    }
    
    public void addEdge(int u, int v, int weight) {
        adj[u][v] = weight;
        // Pour graphe non orienté (symétrique) :
        if (!directed) {
            adj[v][u] = weight;
        }
    }
    
    public boolean hasEdge(int u, int v) {
        return adj[u][v] != 0;
    }
}
```

### Propriétés et caractéristiques intéressantes

#### 1. **Puissance matricielle = Chemin de longueur k**

Élever la matrice M à la puissance k donne le nombre de chemins de longueur exactement k entre deux sommets.

```
M² [i][j] = nombre de chemins de longueur 2 de i à j
M³ [i][j] = nombre de chemins de longueur 3 de i à j
...
M^k [i][j] = nombre de chemins de longueur k de i à j

Exemple : Pour trouver tous les chemins de longueur 3 depuis sommet 1
Calculer M³ et lire la ligne 1
```

#### 2. **Détection de cycle**

Un cycle existe si la **diagonale principale** de **M^k** contient des valeurs non-zéro (k ≥ 1).

```
M[i][i] = 0 pour tout i (pas de boucles)
M²[i][i] > 0 → existe un cycle passant par i de longueur 2
M³[i][i] > 0 → existe un cycle passant par i de longueur 3
```

#### 3. **Graphe connexe / Fortement connexe**

Pour un graphe non orienté : connexe ssi (M + M²+ M³ + ... + M^(n-1)) a tous éléments > 0

Pour un graphe orienté : fortement connexe ssi la même condition avec M*

#### 4. **Transitivité (clôture transitive)**

La **clôture transitive** est obtenue par l'algorithme de Floyd-Warshall :
- Donne toutes les paires (i,j) où un chemin existe
- Utile pour les relations d'équivalence

#### 5. **Mémoire : Dense vs Sparse**

**Degré (degree)** : Le nombre d'arêtes incidentes à un sommet u
- Graphe non orienté : deg(u) = nombre de voisins de u
- Graphe orienté : 
  - **In-degree** : arêtes entrantes
  - **Out-degree** : arêtes sortantes

```
Exemple :     1 → 2 ← 3
                ↓
              4 → 5

deg_out(1) = 2  (arêtes vers 2 et 4)
deg_in(2) = 2   (arêtes de 1 et 3)
deg(5) = 1      (arête de 4 seulement)
```

| Propriété | Matrice | Liste adjacence |
|-----------|---------|-----------------|
| Espace | O(\|V\|²) | O(\|V\| + \|E\|) |
| Graphe dense (\|E\| ≈ \|V\|²) | ✓ Efficace | Surcharge |
| Graphe sparse (\|E\| ≈ \|V\|) | Gaspillage | ✓ Efficace |
| Vérifier arête (u,v) | O(1) | O(deg(u)) ← dépend du nombre de voisins |
| Tous voisins de u | O(\|V\|) | O(deg(u)) ← juste lire la liste des voisins |

**Explication O(deg(u))** :
- **Liste adjacence** : Pour chaque sommet u, on stocke une liste de ses voisins
- Vérifier si (u,v) existe = parcourir la liste des voisins de u
- Plus u a de voisins, plus ça prend de temps
- Si u est très connecté (deg(u) = |V|-1), = O(|V|)
- Si u est peu connecté (deg(u) = 2), = O(2)

#### 6. **Représentation symbolique**

Graphe **bipartite** si la matrice peut être réorganisée en bloc 2×2 :

```
   A  B
A [0  M]
B [M' 0]

M = arêtes de A vers B
M' = arêtes de B vers A
```

### Listes d'adjacence

Pour chaque sommet, maintenir une **liste des voisins**.

```
Graphe :    1 -- 2
            |\  /
            | \/
            | /\
            |/  \
            3 -- 4

Listes d'adjacence :
1 : [2, 3, 4]
2 : [1, 3]
3 : [1, 2, 4]
4 : [1, 3]
```

**Implémentation :**

```java
public class GraphList {
    private List<Integer>[] adj;
    private int numVertices;
    
    @SuppressWarnings("unchecked")
    public GraphList(int n) {
        numVertices = n;
        adj = new ArrayList[n];
        for (int i = 0; i < n; i++) {
            adj[i] = new ArrayList<>();
        }
    }
    
    public void addEdge(int u, int v) {
        adj[u].add(v);
        // Pour graphe non orienté :
        adj[v].add(u);
    }
    
    public List<Integer> getNeighbors(int u) {
        return adj[u];
    }
}
```

**Complexité :**
- Spatiale : O(|V| + |E|)
- Vérifier arête : O(degré)
- Tous les voisins : O(degré)

**Utilité :** Graphes peu denses

## Comparaison

| Aspect | Matrice | Liste |
|--------|---------|-------|
| Espace | O(\|V\|²) | O(\|V\| + \|E\|) |
| Arête | O(1) | O(degré) |
| Voisins | O(\|V\|) | O(degré) |
| Dense | ✓ Bon | Mauvais |
| Peu dense | Mauvais | ✓ Bon |

---

**[↑ Retour à la section 8](README.md)** | **[← Retour à l'index](../INDEX.md)**

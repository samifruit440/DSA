# 2.3 Piles et Files

## Piles (Stack) : structure LIFO (Last In, First Out)

### Concept

Une **pile** est une structure de données où les éléments sont ajoutés et retirés du **même bout** (le sommet). Le dernier élément entré est le premier à sortir.

```
Sommet → [3]
         [2]
         [1]
```

### Opérations standard

```java
Stack<Integer> pile = new Stack<>();

// Opérations principales
pile.push(1);      // Ajouter 1
pile.push(2);      // Ajouter 2
pile.push(3);      // Ajouter 3

int top = pile.peek();  // Voir le sommet (retourne 3, sans supprimer)
int element = pile.pop(); // Retirer le sommet (retourne 3)

boolean vide = pile.empty(); // Vérifier si vide
int taille = pile.size();    // Obtenir la taille
```

### Complexité des opérations

| Opération | Complexité |
|-----------|-----------|
| `push(e)` | O(1) |
| `pop()` | O(1) |
| `peek()` / `top()` | O(1) |
| `isEmpty()` | O(1) |
| `size()` | O(1) |

### Implémentation simplifiée

```java
public class SimpleStack<E> {
    private List<E> elements;
    
    public SimpleStack() {
        elements = new ArrayList<>();
    }
    
    public void push(E element) {
        elements.add(element);
    }
    
    public E pop() {
        if (isEmpty()) throw new EmptyStackException();
        return elements.remove(elements.size() - 1);
    }
    
    public E peek() {
        if (isEmpty()) throw new EmptyStackException();
        return elements.get(elements.size() - 1);
    }
    
    public boolean isEmpty() {
        return elements.isEmpty();
    }
    
    public int size() {
        return elements.size();
    }
}
```

### Application : Évaluation d'expressions post-fixes

Une expression post-fixe (RPN - Reverse Polish Notation) est écrite opérandes d'abord, puis l'opérateur.

Exemple : `3 4 +` = 7 (au lieu de `3 + 4`)

```java
public static int evaluatePostfix(String[] tokens) {
    Stack<Integer> pile = new Stack<>();
    
    for (String token : tokens) {
        if (isOperator(token)) {
            int b = pile.pop();
            int a = pile.pop();
            int result = applyOperator(a, b, token);
            pile.push(result);
        } else {
            pile.push(Integer.parseInt(token));
        }
    }
    
    return pile.pop();
}

// Exemple : "3 4 +" → 7
int result = evaluatePostfix(new String[]{"3", "4", "+"});
```

## Files (Queue) : structure FIFO (First In, First Out)

### Concept

Une **file** est une structure de données où les éléments sont ajoutés à l'**arrière** et retirés de l'**avant**. Le premier élément entré est le premier à sortir.

```
Avant  [1] ← [2] ← [3]  Arrière
       ↓
    Déqueue
```

### Opérations standard

```java
Queue<Integer> file = new LinkedList<>();

// Opérations principales
file.enqueue(1);    // Ajouter à l'arrière
file.enqueue(2);
file.enqueue(3);

int first = file.peek();    // Voir l'avant (retourne 1, sans supprimer)
int element = file.dequeue(); // Retirer l'avant (retourne 1)

boolean vide = file.isEmpty(); // Vérifier si vide
int taille = file.size();      // Obtenir la taille
```

### Complexité des opérations

| Opération | Complexité |
|-----------|-----------|
| `enqueue(e)` | O(1) |
| `dequeue()` | O(1) |
| `peek()` | O(1) |
| `isEmpty()` | O(1) |
| `size()` | O(1) |

### Implémentation simplifiée avec LinkedList

```java
public class SimpleQueue<E> {
    private class Node {
        E value;
        Node next;
        Node(E value) { this.value = value; }
    }
    
    private Node front;
    private Node rear;
    private int size;
    
    public SimpleQueue() {
        size = 0;
    }
    
    public void enqueue(E element) {
        Node newNode = new Node(element);
        if (isEmpty()) {
            front = newNode;
        } else {
            rear.next = newNode;
        }
        rear = newNode;
        size++;
    }
    
    public E dequeue() {
        if (isEmpty()) throw new NoSuchElementException();
        E value = front.value;
        front = front.next;
        if (isEmpty()) rear = null;
        size--;
        return value;
    }
    
    public E peek() {
        if (isEmpty()) throw new NoSuchElementException();
        return front.value;
    }
    
    public boolean isEmpty() {
        return size == 0;
    }
    
    public int size() {
        return size;
    }
}
```

### Application : Tampons de messages

Les files sont utilisées pour gérer les messages dans les systèmes distribués, les imprimantes, les serveurs web, etc.

```java
// Exemple : Gestionnaire de tâches
public class TaskQueue {
    private Queue<String> tasks = new LinkedList<>();
    
    public void submitTask(String task) {
        tasks.offer(task);
        System.out.println("Tâche ajoutée: " + task);
    }
    
    public void processTasks() {
        while (!tasks.isEmpty()) {
            String task = tasks.poll();
            System.out.println("Traitement: " + task);
        }
    }
}

// Utilisation
TaskQueue queue = new TaskQueue();
queue.submitTask("Télécharger fichier");
queue.submitTask("Traiter données");
queue.submitTask("Envoyer rapport");
queue.processTasks();
```

## Comparaison Pile vs File

| Aspect | Pile | File |
|--------|------|------|
| Acronyme | LIFO | FIFO |
| Ajout | Sommet | Arrière |
| Retrait | Sommet | Avant |
| Cas d'usage | Annuler/Refaire, Parcours récursif | Planification de tâches, BFS |
| Ordre | Inversion d'ordre | Maintient l'ordre |

---

**[↑ Retour à la section 2](README.md)** | **[← Retour à l'index](../INDEX.md)**

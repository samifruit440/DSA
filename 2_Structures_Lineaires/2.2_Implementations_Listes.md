# 2.2 Implémentations de Listes

## Implémentation par tableau (ArrayList)

### Concept

ArrayList utilise un **tableau dynamique** pour stocker les éléments. Le tableau s'agrandit automatiquement quand nécessaire.

```java
ArrayList<Integer> liste = new ArrayList<>();
liste.add(10);     // Ajoute à la fin
liste.add(0, 5);   // Ajoute à l'index 0
```

### Complexité des opérations sur ArrayList

| Opération | Complexité | Explication |
|-----------|-----------|-------------|
| `get(i)` | O(1) | Accès direct à l'index |
| `set(i, e)` | O(1) | Remplacement direct |
| `add(e)` | O(1) amorti | Ajout à la fin (doublage rare) |
| `add(i, e)` | O(n) | Décalage des éléments après index |
| `remove(i)` | O(n) | Décalage des éléments après index |
| `contains(e)` | O(n) | Recherche linéaire |
| `size()` | O(1) | Champ stocké |

**Note** : `add(e)` est O(1) **amorti** car le redimensionnement du tableau (qui est O(n)) se produit rarement. Sur une séquence de N insertions, le coût total est O(N), donc O(1) par opération en moyenne.

### Avantages et inconvénients

**Avantages :**
- Accès direct rapide O(1)
- Pas de surcharge mémoire supplémentaire pour pointeurs

**Inconvénients :**
- Opérations d'insertion/suppression coûteuses O(n)
- Peut gaspiller de la mémoire si over-allocated

### Implémentation simplifiée

```java
public class SimpleArrayList<E> {
    private E[] data;
    private int size;
    
    @SuppressWarnings("unchecked")
    public SimpleArrayList() {
        data = new Object[10];
        size = 0;
    }
    
    public void add(E element) {
        if (size == data.length) {
            resize(data.length * 2);
        }
        data[size++] = element;
    }
    
    public E get(int index) {
        if (index < 0 || index >= size) throw new IndexOutOfBoundsException();
        return data[index];
    }
    
    private void resize(int newCapacity) {
        E[] newData = Arrays.copyOf(data, newCapacity);
        data = newData;
    }
}
```

## Implémentation chaînée (LinkedList)

### Concept

LinkedList utilise des **nœuds chaînés** (pointeurs) pour stocker les éléments. Chaque nœud contient une valeur et une référence au nœud suivant.

```
[Valeur | Next] → [Valeur | Next] → [Valeur | Next] → null
```

```java
LinkedList<Integer> liste = new LinkedList<>();
liste.add(10);        // Ajoute à la fin
liste.addFirst(5);    // Ajoute au début
liste.addLast(15);    // Ajoute à la fin
```

### Complexité des opérations sur LinkedList

| Opération | Complexité | Explication |
|-----------|-----------|-------------|
| `get(i)` | O(n) | Parcours du début jusqu'à index |
| `set(i, e)` | O(n) | Parcours + remplacement |
| `add(e)` | O(1) | Ajout à la fin (avec tail pointer) |
| `addFirst(e)` | O(1) | Ajout au début |
| `addLast(e)` | O(1) | Ajout à la fin |
| `remove(i)` | O(n) | Parcours jusqu'à index |
| `removeFirst()` | O(1) | Suppression du début |
| `removeLast()` | O(1) | Suppression de la fin |
| `getFirst()` | O(1) | Accès au début |
| `getLast()` | O(1) | Accès à la fin |
| `size()` | O(1) | Champ stocké |

### Avantages et inconvénients

**Avantages :**
- Insertion/suppression rapides O(1) au début/fin
- Pas de réallocation mémoire
- Utilisation mémoire adaptée

**Inconvénients :**
- Accès aux éléments lent O(n)
- Surcharge mémoire pour pointeurs (next, previous)
- Cache non-optimal

### Implémentation simplifiée

```java
public class SimpleLinkedList<E> {
    private class Node {
        E value;
        Node next;
        Node(E value) { this.value = value; }
    }
    
    private Node head;
    private int size;
    
    public void addFirst(E element) {
        Node newNode = new Node(element);
        newNode.next = head;
        head = newNode;
        size++;
    }
    
    public E getFirst() {
        if (head == null) throw new NoSuchElementException();
        return head.value;
    }
    
    public E get(int index) {
        if (index < 0 || index >= size) throw new IndexOutOfBoundsException();
        Node current = head;
        for (int i = 0; i < index; i++) {
            current = current.next;
        }
        return current.value;
    }
}
```

## Comparaison ArrayList vs LinkedList

| Opération | ArrayList | LinkedList |
|-----------|-----------|-----------|
| Accès aléatoire | ✓ O(1) | ✗ O(n) |
| Ajout/Suppression au début | ✗ O(n) | ✓ O(1) |
| Ajout/Suppression à la fin | ✓ O(1) | ✓ O(1) |
| Ajout/Suppression au milieu | ✗ O(n) | ✗ O(n) |
| Utilisation mémoire | + Efficace | - (pointeurs) |

**Recommandations :**
- Utilisez **ArrayList** si accès fréquent à des éléments arbitraires
- Utilisez **LinkedList** si fréquentes insertions/suppressions au début

---

**[↑ Retour à la section 2](README.md)** | **[← Retour à l'index](../INDEX.md)**
